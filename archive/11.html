<!DOCTYPE html>

<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>ТВОИ ДАННЫЕ — отсек</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
    }

    body {
      background: #000;
      color: #fff;
      font-family: "Anticva", "Times New Roman", serif;
      -webkit-font-smoothing: antialiased;
      overflow: hidden;
    }

    :root {
      --bg: #000;
      --fg: #ffffff;
      --soft: #c9c9c9;
      --muted: #7f7f7f;
      --accent: #ffffff;
      --border: #ffffff;
    }

    .elongated {
      display: inline-block;
      transform: scaleY(1.7);
      transform-origin: center;
      letter-spacing: 0.16em;
    }

    .small-elongated {
      display: inline-block;
      transform: scaleY(1.4);
      transform-origin: center;
      letter-spacing: 0.14em;
    }

    .screen {
      position: fixed;
      inset: 0;
      background: #000;
      color: #fff;
      display: none;
    }

    .screen-visible {
      display: block;
    }

    .screen-inner {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
    }

    /* 01 — заставка с логотипом */
    #screen-splash .screen-inner {
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
    }

    .splash-image {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .splash-hint {
      position: absolute;
      bottom: 24px;
      right: 40px;
      font-size: 10px;
      color: var(--muted);
      letter-spacing: 0.18em;
      text-transform: uppercase;
    }

    /* 02 — В МОЗГ (мозг + квадраты) */

    #screen-brain .screen-inner {
      padding: 48px 72px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 40px;
    }

    .brain-left {
      flex: 1;
    }
    .brain-site-name {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.18em;
      color: var(--muted);
      margin-bottom: 18px;
    }

    .brain-menu {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 380px;
    }

    .brain-menu-btn {
      border: 1px solid #ffffff;
      background: #000000;
      color: #ffffff;
      padding: 10px 16px;
      text-align: left;
      cursor: pointer;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-size: clamp(16px, 2.4vw, 22px);
      width: 100%;
      transition: background 0.15s ease-out, color 0.15s ease-out, transform 0.15s ease-out;
    }

    .brain-menu-btn:hover {
      background: #ffffff;
      color: #000000;
      transform: translateY(-2px);
    }


    .brain-main-title {
      font-size: clamp(32px, 5vw, 46px);
      margin-bottom: 16px;
      text-transform: uppercase;
      display: block;
    }

    .brain-sub {
      font-size: clamp(16px, 2.4vw, 24px);
      text-transform: uppercase;
      margin-bottom: 6px;
      display: block;
    }

    .brain-sub:nth-child(2) {
      margin-top: 18px;
    }

    .brain-sub:last-child {
      margin-top: 6px;
    }

    .brain-left-bottom {
      margin-top: 40px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    .brain-right {
      flex: 0 0 420px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
    }

    .brain-icon {
      width: 260px;
      max-width: 100%;
      cursor: pointer;
      image-rendering: auto;
    }

    .brain-person {
      width: 100px;
      opacity: 0.95;
    }

    .brain-squares {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 120px));
      gap: 14px;
      margin-top: 6px;
    }

    .brain-square {
      border: 2px solid #fff;
      background: transparent;
      cursor: pointer;
      transition: background 0.15s ease-out, transform 0.15s ease-out;
      /* Золотое сечение: ширина / высота ≈ 1.618 */
      aspect-ratio: 1.618 / 1;
    }

    .brain-square:hover {
      background: #fff;
      transform: translateY(-2px);
    }

    .brain-square.small {
      grid-column: span 2;
      /* Перевёрнутое золотое сечение: ширина / высота ≈ 1 / 0.618 */
      aspect-ratio: 1 / 0.618;
    }

    .brain-square-disabled {
      cursor: default;
      opacity: 0.85;
      pointer-events: none;
    }

    .brain-square-label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    .square-relative {
      position: relative;
    }

    .brain-io-row {
      display: flex;
      gap: 16px;
      margin-top: 8px;
      align-items: center;
      justify-content: center;
    }

    .brain-io {
      border: 2px solid #fff;
      width: 120px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      background: transparent;
      transition: background 0.15s ease-out, transform 0.15s ease-out;
    }

    .brain-io:hover {
      background: #fff;
      color: #000;
      transform: translateY(-2px);
    }

    #fileInput {
      display: none;
    }

    .brain-brand {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    .brain-brand-logo {
      width: 120px;
      opacity: 0.95;
    }

    /* 02b — Экран выбора корня (активизация нейронов) */

    #screen-roots .screen-inner {
      padding: 40px 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 40px;
    }

    .roots-header {
      width: 100%;
      text-align: center;
      text-transform: uppercase;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .roots-title {
      font-size: clamp(42px, 7vw, 64px);
    }

    .roots-sub {
      margin-top: 4px;
      font-size: clamp(18px, 3vw, 24px);
      letter-spacing: 0.18em;
    }

    .roots-center {
      width: 100%;
      max-width: 980px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 40px;
    }

    .roots-bracket {
      border: 2px dotted #ffffff;
      height: 260px;
    }

    .roots-bracket-left {
      border-right: none;
    }

    .roots-bracket-right {
      border-left: none;
    }

    .roots-list-wrapper {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 18px;
    }

    .roots-add-btn {
      width: 60px;
      height: 60px;
      border-radius: 14px;
      border: 2px solid #ffffff;
      background: #ffffff;
      color: #000000;
      font-size: 32px;
      cursor: pointer;
    }

    .roots-add-btn:hover {
      transform: translateY(-2px);
    }

    .roots-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 20px;
      text-transform: uppercase;
    }

    .root-item {
      display: flex;
      align-items: baseline;
      gap: 12px;
      cursor: pointer;
    }

    .root-item-star {
      font-size: 26px;
    }

    .root-item-label {
      letter-spacing: 0.09em;
      display: inline-block;
      transform: scaleY(1.4);
      transform-origin: center;
    }

    .root-item:hover .root-item-label {
      text-decoration: underline;
    }

    .roots-empty {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    /* 03 — Основной экран приложения (архивотсек / паттерн) */

    #screen-app .screen-inner {
      padding: 24px 40px 24px 40px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    #appRoot {
      flex: 1;
      display: grid;
      grid-template-columns: 280px minmax(0, 1fr);
      gap: 32px;
    }

    .sidebar {
      border-right: 2px dashed #ffffff;
      padding-right: 24px;
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .sidebar-top {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 18px;
    }

    .sidebar-brand {
      font-size: 22px;
      text-transform: uppercase;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      border: 1px solid #ffffff;
      padding: 4px 12px;
      border-radius: 4px;
    }

    .sidebar-brand:hover {
      background: #ffffff;
      color: #000000;
    }

    .sidebar-brand span {
      display: inline-block;
    }

    .sidebar-plus {
      width: 72px;
      height: 40px;
      border-radius: 6px;
      background: #fff;
      color: #000;
      font-size: 26px;
      border: none;
      cursor: pointer;
      display: none;
    }

    .sidebar-plus:hover {
      transform: translateY(-2px);
    }

    .sidebar-breadcrumb-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
    }

    #breadcrumb {
      margin-top: 4px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      word-break: break-word;
    }

    .sidebar-tree-wrapper {
      margin-top: 16px;
      overflow-y: visible;
      padding-right: 8px;
      font-size: 13px;
      flex: 1;
    }

    /* simple tree look */
    .tree-item {
      padding: 4px 6px;
      border-left: 2px solid transparent;
      cursor: pointer;
      margin-bottom: 4px;
      text-transform: uppercase;
    }

    .tree-item:hover {
      border-left-color: #fff;
      background: #111;
    }

    .tree-item.active {
      border-left-color: #fff;
      background: #111;
    }

    .tree-label {
      font-size: 13px;
    }

    .tree-meta {
      font-size: 9px;
      color: var(--muted);
    }

    .tree-badge {
      display: none;
    }

    .hier-fx {
      font-size: 20px;
      margin-bottom: 8px;
    }

    .hier-row {
      display: flex;
      position: relative;
      align-items: baseline;
      gap: 6px;
      margin-bottom: 10px;
      cursor: pointer;
    }

    .hier-row.hier-row-drop-inside {
      background: rgba(255, 255, 255, 0.08);
    }

    .hier-row.hier-row-drop-before::before,
    .hier-row.hier-row-drop-after::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      border-top: 2px solid #ffffff;
    }

    .hier-row.hier-row-drop-before::before {
      top: -2px;
    }

    .hier-row.hier-row-drop-after::after {
      bottom: -2px;
    }

    .hier-tag {
      font-size: 11px;
      text-transform: lowercase;
      letter-spacing: 0.1em;
      min-width: 56px;
    }

    .hier-name {
      font-size: 16px;
      text-transform: uppercase;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: inline-block;
      transform: scaleY(1.4);
      transform-origin: center;
      letter-spacing: 0.14em;
    }

    .hier-row-current .hier-name {
      text-decoration: underline;
    }

    /* main panel */
    .main-panel {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .main-header-line {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      border-bottom: 2px dashed #fff;
      padding-bottom: 8px;
      margin-bottom: 12px;
    }

    .main-title-wrapper {
      font-size: 26px;
      text-transform: uppercase;
    }

    .main-title-wrapper .small-elongated {
      font-size: 18px;
    }

    #headerActions {
      display: flex;
      gap: 8px;
      font-size: 11px;
      text-transform: uppercase;
    }

    #detailsRoot {
      flex: 1;
      overflow-y: auto;
      padding-right: 8px;
      font-size: 13px;
    }

    .section {
      border: 1px solid #ffffff;
      padding: 8px 10px;
      margin-bottom: 10px;
    }

    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      text-transform: uppercase;
      font-size: 12px;
      cursor: pointer;
    }

    .section-header .section-title {
      display: inline-block;
      transform: scaleY(1.35);
      transform-origin: center;
      letter-spacing: 0.14em;
    }

    .section-body {
      margin-top: 8px;
      font-size: 12px;
    }

    .hint {
      font-size: 11px;
      color: var(--muted);
    }

    .btn {
      font-family: inherit;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      background: #000;
      color: #fff;
      border: 1px solid #fff;
      padding: 4px 10px;
      cursor: pointer;
    }

    .btn-sm {
      font-size: 10px;
      padding: 4px 8px;
    }

    .btn:disabled,
    .btn[disabled] {
      opacity: 0.35;
      cursor: not-allowed;
      border-color: #555555;
      color: #555555;
      background: #000000;
    }

    .btn-primary {
      background: #fff;
      color: #000;
    }

    .btn-ghost {
      background: transparent;
    }

    .btn-danger {
      border-color: #ff6282;
      color: #ff6282;
    }

    .btn-hidden {
      display: none !important;
    }

    .btn-option {
      width: 100%;
      text-align: left;
      margin-bottom: 6px;
    }

    .btn-option-selected {
      background: #fff;
      color: #000;
    }

    .btn-option-correct {
      background: #1c8c3c;
      border-color: #a7ffb0;
      color: #eafff0;
    }

    .btn-option-wrong {
      background: #7b112f;
      border-color: #ff99ba;
      color: #ffe5f1;
    }

    .form-input,
    .form-select,
    .form-textarea {
      width: 100%;
      background: #000;
      border: 1px solid #fff;
      color: #fff;
      padding: 4px 6px;
      font-family: inherit;
      font-size: 12px;
    }

    .form-textarea {
      min-height: 60px;
      resize: vertical;
    }

    .form-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
    }

    .form-row {
      display: grid;
      grid-template-columns: 150px minmax(0, 1fr);
      gap: 6px;
      margin-bottom: 6px;
      align-items: flex-start;
    }

    .row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }

    .row-xs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .child-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .child-card {
      border: 1px solid #fff;
      padding: 4px 6px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      cursor: pointer;
      text-transform: uppercase;
      font-size: 11px;
    }

    .child-card:hover {
      background: #111;
    }

    .child-name {
      max-width: 240px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .child-meta {
      font-size: 9px;
      color: var(--muted);
      display: flex;
      gap: 8px;
    }

    .card-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .card-table th,
    .card-table td {
      border-bottom: 1px solid #444;
      padding: 4px 4px;
      text-align: left;
    }

    .card-table-actions,
    .card-order-controls {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-start;
    }


    /* Кнопка сворачивания левой панели */
    .sidebar-toggle-fixed {
      position: absolute;
      left: 8px;
      top: 12px;
      z-index: 10;
      width: 26px;
      height: 32px;
      border-radius: 16px;
      border: 1px solid #ffffff;
      background: #000000;
      color: #ffffff;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .sidebar-toggle-fixed:hover {
      background: #ffffff;
      color: #000000;
    }

    #appRoot.sidebar-collapsed {
      grid-template-columns: 0 minmax(0, 1fr);
    }

    #appRoot.sidebar-collapsed .sidebar {
      display: none;
    }

    /* overlays: тесты и просмотр фактов */

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.93);
      z-index: 40;
    }

    .overlay-card {
      width: min(860px, 100% - 40px);
      max-height: min(600px, 100% - 80px);
      background: #000;
      border: 1px solid #fff;
      padding: 16px 18px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .overlay-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      border-bottom: 1px dashed #fff;
      padding-bottom: 6px;
    }

    .overlay-title {
      font-size: 20px;
      text-transform: uppercase;
      display: inline-block;
      transform: scaleY(1.4);
      transform-origin: center;
      letter-spacing: 0.14em;
    }

    .overlay-subtitle,
    .overlay-progress {
      font-size: 11px;
      color: var(--muted);
    }

    .overlay-body {
      flex: 1;
      overflow-y: auto;
      font-size: 13px;
    }

    .quiz-question {
      font-size: 14px;
      margin-bottom: 8px;
    }

    .quiz-options {
      margin-top: 4px;
    }

    .quiz-footer {
      border-top: 1px dashed #fff;
      padding-top: 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .quiz-message {
      font-size: 11px;
      color: var(--muted);
      white-space: pre-wrap;
    }

    .facts-text {
      font-size: 13px;
      white-space: pre-wrap;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.93);
      z-index: 50;
    }

    .modal-card {
      width: min(520px, 100% - 40px);
      background: #000;
      border: 1px solid #fff;
      padding: 14px 16px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 13px;
    }

    .modal-header {
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
    }

    .modal-header-main {
      display: flex;
      flex-direction: column;
    }

    .modal-close {
      border: 1px solid #fff;
      background: transparent;
      color: #fff;
      padding: 0 6px;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
      text-transform: none;
    }

    .modal-close:hover {
      background: #fff;
      color: #000;
    }


    .modal-title {
      font-size: 18px;
      text-transform: uppercase;
    }

    .modal-subtitle {
      font-size: 11px;
      color: var(--muted);
      margin-top: 4px;
    }

    .modal-footer {
      margin-top: 12px;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 10px;
      width: 100%;
    }

    .segmented {
      display: inline-flex;
      border: 1px solid #fff;
      padding: 2px;
      gap: 2px;
      margin-top: 4px;
    }

    .segmented button {
      border: none;
      background: transparent;
      color: #fff;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      padding: 3px 6px;
      cursor: pointer;
    }

    .segmented button.active {
      background: #fff;
      color: #000;
    }

    .seg-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-top: 4px;
    }

    /* overlay с текстом про мозг */
    .brain-story-overlay {
      position: fixed;
      inset: 0;
      background: #000;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 60;
    }

    .brain-story-overlay.visible {
      display: flex;
    }

    .brain-story-card {
      max-width: 680px;
      padding: 32px 40px 24px;
      border: 1px solid #fff;
      text-align: center;
      font-size: 16px;
      line-height: 1.6;
    }

    .brain-story-card p {
      margin-bottom: 18px;
    }

    /* RESPONSIVE */

    @media (max-width: 960px) {
      #screen-brain .screen-inner {
        padding: 32px 20px;
        flex-direction: column;
      }
      #appRoot {
        grid-template-columns: minmax(0, 1fr);
      }
      .sidebar {
        border-right: none;
        border-bottom: 2px dashed #fff;
        padding-right: 0;
        padding-bottom: 14px;
        margin-bottom: 10px;
      }
      .screen-inner {
        overflow-y: auto;
      }
      body {
        overflow: hidden;
      }
      .hier-header {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    @media (max-width: 640px) {
      #screen-brain .screen-inner {
        padding-inline: 14px;
      }
      .brain-main-title {
        font-size: 26px;
      }
      .brain-sub {
        font-size: 16px;
      }
      #screen-app .screen-inner {
        padding-inline: 18px;
      }
    }
  
/* --- Overrides: скролл и более понятная иерархия --- */
body {
  overflow-y: auto;
}

.screen-inner {
  overflow-y: auto;
  overflow-x: hidden;
}

#appRoot.sidebar-collapsed {
  grid-template-columns: minmax(0, 1fr);
}

.hier-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 8px;
  gap: 8px;
}


.hier-fx-buttons {
  display: flex;
  gap: 4px;
  font-size: 8px;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  flex-wrap: wrap;
}

.hier-fx-btn {
  border: 1px solid #ffffff;
  background: #000000;
  color: #ffffff;
  padding: 2px 6px;
  cursor: pointer;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  display: inline-block;
  transform: scaleY(1.2);
  transform-origin: center;
  flex: 1 1 auto;
  text-align: center;
  white-space: nowrap;
}

.hier-fx-btn:hover {
  background: #ffffff;
  color: #000000;
}


.hier-row-category {
  color: #ffffff;
}

.hier-row-characteristic {
  color: #c9c9c9;
}

.hier-toggle {
  width: 14px;
  font-size: 10px;
  text-align: center;
  cursor: pointer;
  user-select: none;
}

.hier-toggle-placeholder {
  visibility: hidden;
  cursor: default;
}

  
    .hier-row.hier-row-drop {
      background: rgba(255, 255, 255, 0.08);
    }

  
    .date-exact-row {
      display: flex;
      gap: 6px;
      align-items: center;
    }
</style>
</head>
<body>
  <!-- 01. Заставка -->
  <div id="screen-splash" class="screen screen-visible">
    <div class="screen-inner">
      <img src="01.jpg" alt="ТВОИ ДАННЫЕ" class="splash-image" />
      <div class="splash-hint">нажми, чтобы продолжить</div>
    </div>
  </div>

  <!-- 02. В МОЗГ -->
  <div id="screen-brain" class="screen">
    <div class="screen-inner">
      
      <div class="brain-left">
        <div class="brain-site-name small-elongated">item:crate</div>

        <div class="brain-menu">
          <button class="brain-menu-btn elongated" id="brainTitle" type="button">
            АКТИВИЗАЦИЯ НЕЙРОНОВ
          </button>
          <button class="brain-menu-btn small-elongated" type="button">
            ЗАПИСКИ ОНОИ?
          </button>
          <button class="brain-menu-btn small-elongated" type="button">
            НЕ ЕЩЁ ПОТЕРЯННЫЕ МОМЕНТЫ
          </button>
        </div>

        <div class="brain-left-bottom">
          помоги сам себе<span class="elongated"> а этот сайт кста не поможет </span>
        </div>
      </div
      </div>

      <div class="brain-right">
        <img src="brain_icon.png" alt="Мозг" class="brain-icon" id="brainIcon" />

        <img src="person_data.png" alt="ТВОИ ДАННЫЕ" class="brain-person" />

        <div class="brain-squares">
          <button class="brain-square square-relative brain-square-disabled" id="btnGoToApp" type="button" disabled></button>
          <button class="brain-square"></button>
          <button class="brain-square small"></button>
        </div>

        <div class="brain-io-row">
          <button class="brain-io" id="btnExport">ЭКСПОРТ</button>
          <button class="brain-io" id="btnImport">ИМПОРТ</button>
          <input type="file" id="fileInput" accept="application/json" />
        </div>

        <div class="brain-brand">
          <div class="small-elongated">ТВОИ ДАННЫЕ</div>
        </div>
      </div>
    </div>
  </div>

  <!-- 02b. Экран выбора корня -->
  <div id="screen-roots" class="screen">
    <div class="screen-inner">
      <div class="roots-back small-elongated" id="backToBrainRoots">В МОЗГ</div>
      <div class="roots-header">
        <div class="roots-title elongated">АКТИВИЗАЦИЯ НЕЙРОНОВ</div>
        <div class="roots-sub small-elongated">ВЫБЕРИ КОРЕНЬ</div>
      </div>
      <div class="roots-center">
        <div class="roots-bracket roots-bracket-left"></div>
        <div class="roots-list-wrapper">
          <button class="roots-add-btn" id="btnRootsAdd">+</button>
          <div class="roots-list" id="rootsList"></div>
        </div>
        <div class="roots-bracket roots-bracket-right"></div>
      </div>
    </div>
  </div>

  <!-- 03. Основной интерфейс -->
  <div id="screen-app" class="screen">
    <div class="screen-inner">
      <button class="sidebar-toggle-fixed" id="sidebarToggleFixed">◀</button>
      <div id="appRoot">
        <aside class="sidebar">
          <div class="sidebar-top">
            <div class="sidebar-brand small-elongated" id="backToBrain">
              В МОЗГ
            </div>
            <button class="sidebar-plus" id="btnCreateRootCategory">+</button>
            <div>
              <div class="sidebar-breadcrumb-label">КАТЕГОРИИ</div>
              <div id="breadcrumb"></div>
            </div>
          </div>
          <div class="sidebar-tree-wrapper">
            <div id="treeRoot"></div>
          </div>
        </aside>

        <section class="main-panel">
          <div class="main-header-line">
            <div class="main-title-wrapper">
              <span class="small-elongated" id="mainTitleText">ОТСЕК / ПАТТЕРН</span>
            </div>
            <div id="headerActions"></div>
          </div>
          <div id="detailsRoot"></div>
        </section>
      </div>
    </div>
  </div>

  <!-- Текст при клике на мозг -->
  <div id="brainStory" class="brain-story-overlay">
    <div class="brain-story-card">
      <p>
        Здравствуйте, сайт сделан психически больным человеком, он хотел знать очень много,
        и его мозг не был способен всё уместить, поэтому оно создало этот сайт.
        Ему стало легче, жить, чуть чуть.
      </p>
      <button class="btn btn-sm btn-primary" id="brainStoryClose">вернуться</button>
    </div>
  </div>
  <!-- QUIZ OVERLAY -->
  <div class="overlay" id="quizScreen">
    <div class="overlay-card">
      <div class="overlay-header">
        <div class="overlay-title-block">
          <div class="overlay-title" id="quizHeaderTitle"></div>
          <div class="overlay-subtitle" id="quizProgress"></div>
        </div>
        <div class="overlay-progress">
          Режим теста: фокус — только вопрос и ответы.
        </div>
      </div>
      <div class="overlay-body">
        <div class="quiz-question" id="quizQuestion"></div>
        <div class="quiz-options" id="quizOptions"></div>
      </div>
      <div class="quiz-footer">
        <div class="quiz-message" id="quizMessage"></div>
        <div style="display:flex;gap:8px;">
          <button class="btn btn-sm btn-ghost" id="btnQuizRestart">ЗАНОВО</button>
          <button class="btn btn-sm btn-ghost btn-hidden" id="btnQuizNext">Дальше</button>
          <button class="btn btn-sm btn-danger" id="btnQuizExit">Выйти</button>
        </div>
      </div>
    </div>
  </div>

  <!-- FACTS OVERLAY -->
  <div class="overlay" id="factsScreen">
    <div class="overlay-card">
      <div class="overlay-header">
        <div class="overlay-title-block">
          <div class="overlay-title facts" id="factsHeaderTitle"></div>
          <div class="overlay-subtitle" id="factsProgress"></div>
        </div>
        <div class="overlay-progress" id="factsCount"></div>
      </div>
      <div class="overlay-body">
        <div class="facts-text" id="factsText"></div>
      </div>
      <div class="quiz-footer">
        <div class="facts-footer-left">
          <span>Просмотр фактов без отвлекающих элементов.</span>
        </div>
        <div style="display:flex;gap:8px;">
          <button class="btn btn-sm btn-ghost" id="btnFactPrev">← Назад</button>
          <button class="btn btn-sm btn-ghost" id="btnFactNext">Вперёд →</button>
          <button class="btn btn-sm btn-danger" id="btnFactsClose">Закрыть</button>
        </div>
      </div>
    </div>
  </div>

  <!-- CREATE MODAL -->
  <div class="modal-backdrop" id="createModal">
    <div class="modal-card">
      <div class="modal-header">
        <div class="modal-header-main">
          <div class="modal-title" id="createModalTitle"></div>
          <div class="modal-subtitle" id="createModalSubtitle"></div>
        </div>
        <button type="button" class="modal-close" id="createModalClose">×</button>
      </div>

      <div class="modal-body">
        <div class="form-row" style="margin-bottom:8px;">
          <div class="form-label" id="createNameLabel">Название</div>
          <div>
            <input class="form-input" id="createNameInput" placeholder="Например: «История Беларуси»" />
            <div class="form-helper">Можно оставить пустым — имя подставится автоматически.</div>
          </div>
        </div>

        <div id="createConfigBlock">
          <div class="seg-group">
            <div class="seg-title">Где используется эта категория?</div>
            <div class="segmented" id="segConfigScope">
              <button type="button" data-scope="subject">УЧЕБНЫЙ ПРЕДМЕТ</button>
              <button type="button" data-scope="personal">ЛИЧНОЕ / СВОИ ЗАМЕТКИ</button>
            </div>
          </div>

          <div class="seg-group" id="configPresetSubject">
            <div class="seg-title">Готовый пресет предмета</div>
            <div class="segmented" id="segConfigPresetSubject">
              <button type="button" data-preset="history">ИСТОРИЯ</button>
              <button type="button" data-preset="english">АНГЛИЙСКИЙ</button>
            </div>
          </div>

          <div class="seg-group" id="configPresetPersonal">
            <div class="seg-title">Личные пространства</div>
            <div class="segmented" id="segConfigPresetPersonal">
              <button type="button" data-preset="notes">ЗАМЕТКИ</button>
              <button type="button" data-preset="ideas">ИДЕИ / ЧЕРНОВИКИ</button>
            </div>
          </div>
        </div>
      </div>

      <div id="createPatternTypeBlock" style="display:none; margin-top:8px;">
        <div class="seg-title">Тип паттерна</div>
        <div class="segmented" id="segPatternType">
          <button type="button" data-ptype="assertion">ФАКТЫ</button>
          <button type="button" data-ptype="years">ГОДА</button>
          <button type="button" data-ptype="olist">ОБЪЕКТНЫЕ СПИСКИ</button>
          <button type="button" data-ptype="term">СЛОВА-ОПРЕДЕЛЕНИЯ</button>
        </div>
      </div>

      <div class="modal-footer">
        <button class="btn btn-sm btn-ghost" id="btnCreateCancel">Отмена</button>
        <button class="btn btn-sm btn-primary" id="btnCreateConfirm">Создать</button>
      </div>
    </div>
  </div>

<script>
    // ===== DOM ELEMENTS =====

    const treeRootEl = document.getElementById('treeRoot');
    let dragNodeId = null;
    let dragOverMode = null;

    // Включаем встроенную проверку орфографии браузера для всех полей ввода текста
    document.addEventListener('focusin', (e) => {
      const t = e.target;
      if (!t || !t.tagName) return;
      const tag = t.tagName.toLowerCase();
      if (tag === 'textarea') {
        t.setAttribute('spellcheck', 'true');
      } else if (tag === 'input') {
        const type = (t.getAttribute('type') || 'text').toLowerCase();
        if (type === 'text' || type === 'search') {
          t.setAttribute('spellcheck', 'true');
        }
      }
    });


    if (treeRootEl) {
      treeRootEl.addEventListener('dragstart', (e) => {
        const row = e.target.closest('.hier-row');
        if (!row || !row.dataset.id) return;
        dragNodeId = row.dataset.id;
        dragOverMode = null;
        if (e.dataTransfer) {
          e.dataTransfer.effectAllowed = 'move';
          try {
            e.dataTransfer.setData('text/plain', dragNodeId);
          } catch (err) {}
        }
      });

      treeRootEl.addEventListener('dragover', (e) => {
        const row = e.target.closest('.hier-row');
        if (!row) return;
        e.preventDefault();

        const rect = row.getBoundingClientRect();
        const offsetY = e.clientY - rect.top;
        let mode = 'inside';
        if (offsetY < rect.height * 0.25) {
          mode = 'before';
        } else if (offsetY > rect.height * 0.75) {
          mode = 'after';
        }

        dragOverMode = mode;

        // очистим старые подсветки
        Array.from(treeRootEl.querySelectorAll('.hier-row')).forEach(r => {
          r.classList.remove('hier-row-drop', 'hier-row-drop-before', 'hier-row-drop-after', 'hier-row-drop-inside');
        });

        if (mode === 'before') {
          row.classList.add('hier-row-drop-before');
        } else if (mode === 'after') {
          row.classList.add('hier-row-drop-after');
        } else {
          row.classList.add('hier-row-drop-inside');
        }

        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = 'move';
        }
      });

      treeRootEl.addEventListener('dragleave', (e) => {
        const row = e.target.closest('.hier-row');
        if (!row) return;
        row.classList.remove('hier-row-drop', 'hier-row-drop-before', 'hier-row-drop-after', 'hier-row-drop-inside');
      });

      treeRootEl.addEventListener('drop', (e) => {
        const row = e.target.closest('.hier-row');
        if (!row || !row.dataset.id) return;
        e.preventDefault();
        const targetId = row.dataset.id;
        const draggedId = dragNodeId;
        dragNodeId = null;

        Array.from(treeRootEl.querySelectorAll('.hier-row')).forEach(r => {
          r.classList.remove('hier-row-drop', 'hier-row-drop-before', 'hier-row-drop-after', 'hier-row-drop-inside');
        });

        if (!draggedId || draggedId === targetId) {
          dragOverMode = null;
          return;
        }

        const draggedNode = getNode(draggedId);
        const targetNode = getNode(targetId);
        if (!draggedNode || !targetNode) {
          dragOverMode = null;
          return;
        }

        let mode = dragOverMode || 'inside';
        let newParentId;
        let afterSiblingId = null;

        if (mode === 'inside' && targetNode.type === 'category') {
          // Бросили внутрь категории — кладём в конец её содержимого
          newParentId = targetNode.id;
        } else {
          // Бросили между соседями — работаем на уровне родителя
          const parent = getNode(targetNode.parentId || state.rootId);
          if (!parent) {
            dragOverMode = null;
            return;
          }
          newParentId = parent.id;
          const siblings = parent.children || [];
          const idx = siblings.indexOf(targetNode.id);

          if (mode === 'before') {
            if (idx <= 0) {
              // вставка в самое начало
              afterSiblingId = '__FIRST__';
            } else {
              // вставка после предыдущего соседа => визуально "перед" текущим
              afterSiblingId = siblings[idx - 1];
            }
          } else {
            // after или inside по не‑категории — просто после целевого узла
            afterSiblingId = targetNode.id;
          }
        }

        moveNode(draggedId, newParentId, afterSiblingId);
        dragOverMode = null;
        render();
      });

      treeRootEl.addEventListener('dragend', () => {
        dragNodeId = null;
        dragOverMode = null;
        Array.from(treeRootEl.querySelectorAll('.hier-row')).forEach(r => {
          r.classList.remove('hier-row-drop', 'hier-row-drop-before', 'hier-row-drop-after', 'hier-row-drop-inside');
        });
      });
    }

    const detailsRootEl = document.getElementById('detailsRoot');
    const breadcrumbEl = document.getElementById('breadcrumb');
    const headerActionsEl = document.getElementById('headerActions');
    const mainTitleTextEl = document.getElementById('mainTitleText');

    const btnCreateRootCategory = document.getElementById('btnCreateRootCategory');
    const rootsListEl = document.getElementById('rootsList');
    const btnRootsAdd = document.getElementById('btnRootsAdd');

    const btnExport = document.getElementById('btnExport');
    const btnImport = document.getElementById('btnImport');
    const fileInput = document.getElementById('fileInput');

    const quizScreenEl = document.getElementById('quizScreen');
    const quizHeaderTitleEl = document.getElementById('quizHeaderTitle');
    const quizProgressEl = document.getElementById('quizProgress');
    const quizQuestionEl = document.getElementById('quizQuestion');
    const quizOptionsEl = document.getElementById('quizOptions');
    const quizMessageEl = document.getElementById('quizMessage');
    const btnQuizExit = document.getElementById('btnQuizExit');
    const btnQuizRestart = document.getElementById('btnQuizRestart');
    const btnQuizNext = document.getElementById('btnQuizNext');

    const factsScreenEl = document.getElementById('factsScreen');
    const factsHeaderTitleEl = document.getElementById('factsHeaderTitle');
    const factsTextEl = document.getElementById('factsText');
    const factsProgressEl = document.getElementById('factsProgress');
    const factsCountEl = document.getElementById('factsCount');
    const btnFactsClose = document.getElementById('btnFactsClose');
    const btnFactPrev = document.getElementById('btnFactPrev');
    const btnFactNext = document.getElementById('btnFactNext');

    const createModalEl = document.getElementById('createModal');
    const createModalTitleEl = document.getElementById('createModalTitle');
    const createModalSubtitleEl = document.getElementById('createModalSubtitle');
    const createNameLabelEl = document.getElementById('createNameLabel');
    const createNameInputEl = document.getElementById('createNameInput');
    const createConfigBlockEl = document.getElementById('createConfigBlock');
    const segConfigScopeEl = document.getElementById('segConfigScope');
    const configPresetSubjectEl = document.getElementById('configPresetSubject');
    const configPresetPersonalEl = document.getElementById('configPresetPersonal');
    const segConfigPresetSubjectEl = document.getElementById('segConfigPresetSubject');
    const segConfigPresetPersonalEl = document.getElementById('segConfigPresetPersonal');
    const createPatternTypeBlockEl = document.getElementById('createPatternTypeBlock');
    const segPatternTypeEl = document.getElementById('segPatternType');
    const btnCreateClose = document.getElementById('createModalClose');
    const btnCreateCancel = document.getElementById('btnCreateCancel');
    const btnCreateConfirm = document.getElementById('btnCreateConfirm');

    // ===== DATA MODEL =====

    function createInitialState() {
      const rootId = 'root';
      return {
        rootId,
        nextId: 1,
        nodes: {
          [rootId]: {
            id: rootId,
            type: 'category',
            name: 'Моя база знаний',
            parentId: null,
            children: [],
            cards: [],
            config: null
          }
        }
      };
    }

    const STORAGE_KEY = 'exam-helper-state-v1';

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return createInitialState();
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== 'object' || !parsed.nodes) {
          return createInitialState();
        }
        return parsed;
      } catch (e) {
        console.warn('Failed to load state, using initial', e);
        return createInitialState();
      }
    }

    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.warn('Failed to save state', e);
      }
    }

    let state = loadState();
    let currentNodeId = state.rootId;
    let quizState = null;
    let factsState = null;
    let treeExpanded = {};
    let sidebarViewNodeId = state.rootId;

    // База данных разработчика (item:корни).
    // Вшита прямо в этот файл как embeddedDeveloperDB,
    // а при наличии exam-db.json рядом с HTML — подменяется свежей версией.
    const embeddedDeveloperDB = {"rootId": "root", "nextId": 141, "nodes": {"root": {"id": "root", "name": "Категории", "type": "category", "parentId": null, "children": ["n1"], "cards": []}, "n1": {"id": "n1", "name": "История Беларуси", "type": "category", "parentId": "root", "children": ["n2"], "config": {"scope": "subject", "preset": "history"}, "cards": []}, "n2": {"id": "n2", "name": "ВКЛ", "type": "category", "parentId": "n1", "children": ["n3", "n83"], "cards": []}, "n3": {"id": "n3", "name": "Князья", "type": "category", "parentId": "n2", "children": ["n9", "n26", "n32", "n40", "n46", "n56"], "cards": []}, "n9": {"id": "n9", "name": "Миндовг", "type": "category", "parentId": "n3", "children": ["n10", "n23", "n74"], "cards": []}, "n10": {"id": "n10", "name": "Года", "type": "characteristic", "parentId": "n9", "children": [], "factType": "years", "cards": [{"id": "n11", "kind": "years", "event": "Миндовг уже имел значительную власть и контролировал определенную часть литовских земель - \"Литва Миндовга\", хотя еще не правил всей Литвой", "timeRaw": "1235", "era": "н. э.", "person": "Миндовг"}, {"id": "n12", "kind": "years", "event": "произошла битва под Шяуляем, где литовцы, во главе Миндовга, разгромили Орден меченосцев", "timeRaw": "1236", "era": "н. э.", "person": "Миндовг"}, {"id": "n13", "kind": "years", "event": "Миндовг стал князем Новогородского(Новогрудок) княжества", "timeRaw": "1240", "era": "н. э.", "person": "Миндовг"}, {"id": "n14", "kind": "years", "event": "Миндовг принял православие", "timeRaw": "1246", "era": "н. э.", "person": "Миндовг"}, {"id": "n15", "kind": "years", "event": "Миндовг принял католичество", "timeRaw": "1251", "era": "н. э.", "person": "Миндовг"}, {"id": "n16", "kind": "years", "event": "Миндовг короновался в Новгородке (Можно считать официальной датой создания ВКЛ)", "timeRaw": "1253", "era": "н. э.", "person": "Миндовг"}, {"id": "n17", "kind": "years", "event": "произошла битва на озере Дурбе, под командованием Миндовга, против Тевтонского ордена", "timeRaw": "1260", "era": "н. э.", "person": "Миндовг"}, {"id": "n18", "kind": "years", "event": "Миндовг разорвал союз с крестоносцами, и заключил союз с Александром Невским", "timeRaw": "1261", "era": "н. э.", "person": "Миндовг"}, {"id": "n19", "kind": "years", "event": "Миндовг был убит в результате заговора между Тройнатом, Товтивилом, Довмонтом", "timeRaw": "1263", "era": "н. э.", "person": "Миндовг"}]}, "n23": {"id": "n23", "name": "Факт", "type": "characteristic", "parentId": "n9", "children": [], "factType": "assertion", "cards": [{"id": "n24", "kind": "assertion", "text": "первый князь ВКЛ, объединил Литву и Новогородское княжество в одно государство", "subject": "Миндовг"}, {"id": "n25", "kind": "assertion", "text": "Годы правления: 1253 - 1263 гг.", "subject": "Миндовг"}]}, "n26": {"id": "n26", "name": "Тройнат", "type": "category", "parentId": "n3", "children": ["n28"], "cards": []}, "n28": {"id": "n28", "name": "Факт", "type": "characteristic", "parentId": "n26", "children": [], "factType": "years", "cards": [{"id": "n29", "kind": "assertion", "text": "один из заговорщиков против Миндовга", "subject": "Тройнат"}, {"id": "n30", "kind": "assertion", "text": "стал князем ВКЛ после убийства Миндовга", "subject": "Тройнат"}, {"id": "n31", "kind": "assertion", "text": "его правление сопровождалось междоусобицами и нестабильностью", "subject": "Тройнат"}]}, "n32": {"id": "n32", "name": "Войшелк", "type": "category", "parentId": "n3", "children": ["n33"], "cards": []}, "n33": {"id": "n33", "name": "Факт", "type": "characteristic", "parentId": "n32", "children": [], "factType": "assertion", "cards": [{"id": "n34", "kind": "assertion", "text": "сын Миндовга", "subject": "Войшелк"}, {"id": "n35", "kind": "assertion", "text": "принял монашество", "subject": "Войшелк"}, {"id": "n36", "kind": "assertion", "text": "после убийства Тройната вернулся к власти", "subject": "Войшелк"}, {"id": "n37", "kind": "assertion", "text": "передал власть Шварну", "subject": "Войшелк"}, {"id": "n38", "kind": "assertion", "text": "был убит Левом Даниловичем", "subject": "Войшелк"}, {"id": "n39", "kind": "assertion", "text": "его правление способствовало укреплению христианства", "subject": "Войшелк"}]}, "n40": {"id": "n40", "name": "Тройдень", "type": "category", "parentId": "n3", "children": ["n41", "n43"], "cards": []}, "n41": {"id": "n41", "name": "Факт", "type": "characteristic", "parentId": "n40", "children": [], "factType": "assertion", "cards": [{"id": "n42", "kind": "assertion", "text": "один из князей ВКЛ, пришёл к власти после Войшелка", "subject": "Тройдень"}]}, "n43": {"id": "n43", "name": "Года", "type": "characteristic", "parentId": "n40", "children": [], "factType": "years", "cards": [{"id": "n44", "kind": "years", "event": "Тройдень разбил татар возле Гродно и Слонима", "timeRaw": "1277", "era": "н. э.", "person": "Тройдень"}, {"id": "n45", "kind": "years", "event": "Тройдень воевал с крестоносцами возле Динабурга", "timeRaw": "1281", "era": "н. э.", "person": "Тройдень"}]}, "n46": {"id": "n46", "name": "Витень", "type": "category", "parentId": "n3", "children": ["n47", "n50"], "cards": []}, "n47": {"id": "n47", "name": "Факт", "type": "characteristic", "parentId": "n46", "children": [], "factType": "assertion", "cards": [{"id": "n48", "kind": "assertion", "text": "князь ВКЛ до Гедимина", "subject": "Витень"}, {"id": "n49", "kind": "assertion", "text": "укреплял государство и вел борьбу с крестоносцами", "subject": "Витень"}, {"id": "n51", "kind": "assertion", "text": "при нём ВКЛ усилило своё влияние в регионе", "subject": "Витень"}]}, "n50": {"id": "n50", "name": "Года", "type": "characteristic", "parentId": "n46", "children": [], "factType": "years", "cards": [{"id": "n52", "kind": "years", "event": "битва Витеня с крестоносцами под Рудой", "timeRaw": "1298", "era": "н. э.", "person": "Витень"}, {"id": "n53", "kind": "years", "event": "укрепление Витенем Новогрудка как одного из центров ВКЛ", "timeRaw": "1316", "era": "н. э.", "person": "Витень"}, {"id": "n54", "kind": "years", "event": "приблизительное время смерти Витеня", "timeRaw": "1316", "era": "н. э.", "person": "Витень"}]}, "n56": {"id": "n56", "name": "Гедимин", "type": "category", "parentId": "n3", "children": ["n57", "n58"], "cards": []}, "n57": {"id": "n57", "name": "Года", "type": "characteristic", "parentId": "n56", "children": [], "factType": "years", "cards": [{"id": "n60", "kind": "years", "event": "Гедимин основал Вильно и перенес столицу в Вильно", "timeRaw": "1323", "era": "н. э.", "person": "Гедимин"}, {"id": "n65", "kind": "years", "event": "битва Гедимина на реке Окмене", "timeRaw": "1331", "era": "н. э.", "person": "Гедимин"}]}, "n58": {"id": "n58", "name": "Факт", "type": "characteristic", "parentId": "n56", "children": [], "factType": "assertion", "cards": [{"id": "n59", "kind": "assertion", "text": "великая князь ВКЛ, при котором государство значительно усилилось", "subject": "Гедимин"}, {"id": "n61", "kind": "assertion", "text": "при Гедимине ВКЛ активно расширяло свои территории на восток и запад", "subject": "Гедимин"}, {"id": "n62", "kind": "assertion", "text": "известен дипломатическими письмами западноевропейским правителям и орденам", "subject": "Гедимин"}, {"id": "n63", "kind": "assertion", "text": "стремился привлечь в ВКЛ ремесленников и купцов из Европы", "subject": "Гедимин"}, {"id": "n64", "kind": "assertion", "text": "при нём ВКЛ укрепило позиции в борьбе с Тевтонским орденом", "subject": "Гедимин"}, {"id": "n66", "kind": "assertion", "text": "династия Гедиминовичей стала одной из ведущих династий Восточной Европы", "subject": "Гедимин"}, {"id": "n67", "kind": "assertion", "text": "сыновья Гедимина правили в разных частях ВКЛ и соседних землях", "subject": "Гедимин"}, {"id": "n68", "kind": "assertion", "text": "Гедимин поддерживал относительную религиозную терпимость в государстве", "subject": "Гедимин"}, {"id": "n69", "kind": "assertion", "text": "при нём укреплялась роль Вильно как политического и культурного центра", "subject": "Гедимин"}, {"id": "n70", "kind": "assertion", "text": "его политика заложила основу дальнейшего усиления ВКЛ при его преемниках", "subject": "Гедимин"}, {"id": "n71", "kind": "assertion", "text": "Гедимин стал родоначальником династии, связанной с многими европейскими правящими домами", "subject": "Гедимин"}, {"id": "n72", "kind": "assertion", "text": "его правление считается одним из ключевых этапов формирования мощи ВКЛ", "subject": "Гедимин"}]}, "n74": {"id": "n74", "type": "characteristic", "name": "123", "parentId": "n9", "children": [], "factType": "assertion", "cards": []}, "n83": {"id": "n83", "type": "category", "name": "Система государственной власти", "parentId": "n2", "children": ["n84", "n112", "n118"], "cards": [], "config": null}, "n84": {"id": "n84", "type": "category", "name": "Верхняя власть", "parentId": "n83", "children": ["n87", "n100", "n107"], "cards": [], "config": null}, "n87": {"id": "n87", "type": "category", "name": "ВЕЛИКИЙ КНЯЗЬ ЛИТВОСКИЙ", "parentId": "n84", "children": ["n89", "n94"], "cards": [], "config": null}, "n89": {"id": "n89", "type": "characteristic", "name": "НАИМИНОВАНИЯ", "parentId": "n87", "children": [], "factType": "olist", "cards": [{"id": "n96", "kind": "olist-item", "text": "Великий князь литовский"}, {"id": "n97", "kind": "olist-item", "text": "король"}, {"id": "n98", "kind": "olist-item", "text": "господарь"}, {"id": "n99", "kind": "olist-item", "text": "король литвы и руси"}]}, "n94": {"id": "n94", "type": "characteristic", "name": "факты", "parentId": "n87", "children": [], "factType": "assertion", "cards": [{"id": "n95", "kind": "assertion", "text": "наследственная власть", "subject": "ВЕЛИКИЙ КНЯЗЬ ЛИТВОСКИЙ"}]}, "n100": {"id": "n100", "type": "category", "name": "паны-рада", "parentId": "n84", "children": ["n101"], "cards": [], "config": null}, "n101": {"id": "n101", "type": "characteristic", "name": "факты", "parentId": "n100", "children": [], "factType": "assertion", "cards": [{"id": "n103", "kind": "assertion", "text": "с 14 века - совещательный орган при князе", "subject": "паны-рада"}, {"id": "n105", "kind": "assertion", "text": "\"преднейшая лавица\" - постоянно действующий орган власти  в стране (центральная администрация, местное управление...)", "subject": "паны-рада"}, {"id": "n106", "kind": "assertion", "text": "1492 год, 1506год -привилей Александра Раде, о расширении полномочий - законодательные органы власти", "subject": "паны-рада"}]}, "n107": {"id": "n107", "type": "category", "name": "сейм", "parentId": "n84", "children": ["n108"], "cards": [], "config": null}, "n108": {"id": "n108", "type": "characteristic", "name": "факты", "parentId": "n107", "children": [], "factType": "assertion", "cards": [{"id": "n109", "kind": "assertion", "text": "сьезд шляхты в вкл", "subject": "сейм"}, {"id": "n110", "kind": "assertion", "text": "с 1511 года шляхта заседала по 2 представителя от поветов", "subject": "сейм"}, {"id": "n111", "kind": "assertion", "text": "с 14 века - высший законодательный орган власти", "subject": "сейм"}]}, "n112": {"id": "n112", "type": "category", "name": "центральная власть", "parentId": "n83", "children": ["n114"], "cards": [], "config": null}, "n114": {"id": "n114", "type": "characteristic", "name": "урядники", "parentId": "n112", "children": [], "factType": "term", "cards": [{"id": "n115", "kind": "term", "word": "канцлер", "definition": "заведовал государственной канцелярией, печатью"}, {"id": "n116", "kind": "term", "word": "гетман наивысший", "definition": "командовал войском вкл"}, {"id": "n117", "kind": "term", "word": "подскарбий земкский", "definition": "заведовал казной (скарбом) вкл"}]}, "n118": {"id": "n118", "type": "category", "name": "местное управление", "parentId": "n83", "children": ["n124"], "cards": [], "config": null}, "n121": {"id": "n121", "type": "characteristic", "name": "административные единицы", "parentId": "n124", "children": [], "factType": "term", "cards": [{"id": "n122", "kind": "term", "word": "Воеводство", "definition": "крупнейшая административная единица, делилось на поветы (на современный лад - области)"}, {"id": "n123", "kind": "term", "word": "повет = волость", "definition": "административная единица (на современный лад - район)"}]}, "n124": {"id": "n124", "type": "category", "name": "АДМИНИСТРАТИВНЫЕ ЕДИНИЦЫ", "parentId": "n118", "children": ["n121", "n125", "n126"], "cards": [], "config": null}, "n125": {"id": "n125", "type": "category", "name": "Воеводство", "parentId": "n124", "children": ["n131"], "cards": [], "config": null}, "n126": {"id": "n126", "type": "category", "name": "повет(волость)", "parentId": "n124", "children": ["n137", "n140"], "cards": [], "config": null}, "n131": {"id": "n131", "type": "characteristic", "name": "ПРЕДСТАВИТЕЛИ ВОЕВОДСТВА", "parentId": "n125", "children": [], "factType": "term", "cards": [{"id": "n132", "kind": "term", "word": "воевода", "definition": "сменил княжеского наместника; из местной шляхты; назначен пожизненно; присутствовал на заседании рады и сейма"}, {"id": "n133", "kind": "term", "word": "каштелян", "definition": "возглавлял войско воеводства"}, {"id": "n135", "kind": "term", "word": "городничий", "definition": "отвечал за укрепление воеводского замка"}, {"id": "n136", "kind": "term", "word": "ключник", "definition": "отвечал за сбор податей"}]}, "n137": {"id": "n137", "type": "characteristic", "name": "ПРЕДСТАВИТЕЛИ повета", "parentId": "n126", "children": [], "factType": "term", "cards": [{"id": "n138", "kind": "term", "word": "староста", "definition": "руководил районом, представитель местной шляхты"}, {"id": "n139", "kind": "term", "word": "Тиун", "definition": "старец,, отвечал за сбор податей в государственную казну"}]}, "n140": {"id": "n140", "type": "characteristic", "name": "определения повета", "parentId": "n126", "children": [], "factType": "term", "cards": [{"id": "n141", "kind": "term", "word": "волость(10-30 сёл)", "definition": "сельский войт"}]}}};
    window.__developerState = embeddedDeveloperDB;

    (function loadDeveloperState() {
      try {
        fetch('exam-db.json')
          .then(resp => {
            if (!resp.ok) throw new Error('HTTP ' + resp.status);
            return resp.json();
          })
          .then(data => {
            if (data && typeof data === 'object' && data.nodes && data.rootId) {
              window.__developerState = data;
              // Обновим экран корней, если он уже открыт
              try {
                renderRootsScreen();
              } catch (e) {
                console.warn('Cannot re-render roots screen after developer DB load', e);
              }
            }
          })
          .catch(err => {
            console.warn('Не удалось загрузить внешнюю exam-db.json с корнями разработчика (используем встроенную версию):', err);
          });
      } catch (err) {
        console.warn('fetch exam-db.json не поддерживается в этом окружении (используем встроенную версию)', err);
      }
    })();

    function genId() {
      state.nextId = (state.nextId || 1) + 1;
      return 'n' + state.nextId;
    }

    function getNode(id) {
      return state.nodes[id] || null;
    }

    function createCategory(name, parentId, config = null) {
      const id = genId();
      state.nodes[id] = {
        id,
        type: 'category',
        name: name || '',
        parentId: parentId || state.rootId,
        children: [],
        cards: [],
        config: config || null
      };
      const parent = getNode(parentId || state.rootId);
      if (parent) {
        parent.children = parent.children || [];
        parent.children.push(id);
      }
      saveState();
      return id;
    }

    function createCharacteristic(name, parentId, factType = 'assertion') {
      const id = genId();
      const node = {
        id,
        type: 'characteristic',
        name: name || '',
        parentId: parentId || state.rootId,
        children: [],
        factType: factType || 'assertion',
        cards: []
      };
      state.nodes[id] = node;
      const parent = getNode(parentId || state.rootId);
      if (parent) {
        parent.children = parent.children || [];
        parent.children.push(id);
      }
      saveState();
      return id;
    }

    function renameNode(id, name) {
      const n = getNode(id);
      if (!n) return;
      if (!name || !name.trim()) return;
      n.name = name.trim();
      saveState();
    }

    function deleteNodeAndDescendants(id) {
      if (id === state.rootId) return;
      const node = getNode(id);
      if (!node) return;
      const parent = getNode(node.parentId);
      if (parent) {
        parent.children = (parent.children || []).filter(c => c !== id);
      }
      function walkRemove(nodeId) {
        const n = getNode(nodeId);
        if (!n) return;
        (n.children || []).forEach(ch => walkRemove(ch));
        delete state.nodes[nodeId];
      }
      walkRemove(id);
      saveState();
    }

    function moveNode(nodeId, newParentId, afterSiblingId = null) {
      const node = getNode(nodeId);
      const newParent = getNode(newParentId);
      if (!node || !newParent) return;
      if (node.id === state.rootId) return;

      // не даём переместить узел внутрь самого себя или своего потомка
      let p = newParent;
      while (p) {
        if (p.id === node.id) return;
        p = getNode(p.parentId);
      }

      const oldParent = getNode(node.parentId);
      if (oldParent && oldParent.children) {
        oldParent.children = oldParent.children.filter(c => c !== node.id);
      }

      newParent.children = newParent.children || [];

      // Специальный маркер: вставить в самое начало списка детей
      if (afterSiblingId === '__FIRST__') {
        newParent.children = newParent.children.filter(c => c !== node.id);
        newParent.children.unshift(node.id);
      }
      // если нужно — вставляем сразу после указанного соседа
      else if (afterSiblingId && newParent.children.includes(afterSiblingId)) {
        const idx = newParent.children.indexOf(afterSiblingId);
        // на всякий случай удалим узел, если он уже был в этом списке
        newParent.children = newParent.children.filter(c => c !== node.id);
        newParent.children.splice(idx + 1, 0, node.id);
      } else {
        // по умолчанию кладём в конец
        if (!newParent.children.includes(node.id)) {
          newParent.children.push(node.id);
        }
      }

      node.parentId = newParent.id;
      saveState();
    }

    // --- FACT CARDS ---

    function addAssertionCard(nodeId, text, subject) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      node.factType = 'assertion';
      node.cards = node.cards || [];
      node.cards.push({
        id: genId(),
        kind: 'assertion',
        text: (text || '').trim(),
        subject: (subject || '').trim() || null
      });
      saveState();
    }

    function addYearsCard(nodeId, event, timeRaw, era, person, timeExact) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      node.factType = 'years';
      node.cards = node.cards || [];
      node.cards.push({
        id: genId(),
        kind: 'years',
        event: (event || '').trim(),
        timeRaw: (timeRaw || '').trim(),
        era: (era || '').trim(),
        person: (person || '').trim() || null,
        timeExact: (timeExact || '').trim() || null
      });
      saveState();
    }

    function addOListItem(nodeId, text) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      node.factType = 'olist';
      node.cards = node.cards || [];
      node.cards.push({
        id: genId(),
        kind: 'olist-item',
        text: (text || '').trim()
      });
      saveState();
    }

    function addTermCard(nodeId, word, definition) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      node.factType = 'term';
      node.cards = node.cards || [];
      node.cards.push({
        id: genId(),
        kind: 'term',
        word: (word || '').trim(),
        definition: (definition || '').trim()
      });
      saveState();
    }

    
    function updateCard(nodeId, cardId, patch) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      const cards = node.cards || [];
      const card = cards.find(c => c.id === cardId);
      if (!card) return;
      Object.assign(card, patch);
      saveState();
    }

function deleteCard(nodeId, cardId) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      node.cards = (node.cards || []).filter(c => c.id !== cardId);
      saveState();
    }

    function moveCard(nodeId, cardId, direction) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      const cards = node.cards || [];
      const index = cards.findIndex(c => c.id === cardId);
      if (index === -1) return;
      const newIndex = direction === 'up' ? index - 1 : index + 1;
      if (newIndex < 0 || newIndex >= cards.length) return;
      const [moved] = cards.splice(index, 1);
      cards.splice(newIndex, 0, moved);
      saveState();
    }

    // ===== UTILS =====

    function isValidYearOrPeriod(str) {
      const s = (str || '').trim();
      if (!s) return false;
      const single = /^\d{1,4}$/;
      const range = /^(\d{1,4})\s*[-–—]\s*(\d{1,4})$/;
      return single.test(s) || range.test(s);
    }

    function normalizeMonthName(monthRaw) {
      const m = (monthRaw || '').toLowerCase().trim();
      if (!m) return '';
      // оставляем только буквы (латиница + кириллица)
      const s = m.normalize('NFD').replace(/[^a-zа-яё]+/g, '');
      return s;
    }

    function getMaxDaysForMonth(monthRaw) {
      const m = normalizeMonthName(monthRaw);
      if (!m) return 31;
      const ru = {
        'январь': 31, 'января': 31,
        'февраль': 28, 'февраля': 28,
        'март': 31, 'марта': 31,
        'апрель': 30, 'апреля': 30,
        'май': 31, 'мая': 31,
        'июнь': 30, 'июня': 30,
        'июль': 31, 'июля': 31,
        'август': 31, 'августа': 31,
        'сентябрь': 30, 'сентября': 30,
        'октябрь': 31, 'октября': 31,
        'ноябрь': 30, 'ноября': 30,
        'декабрь': 31, 'декабря': 31
      };
      if (ru[m] != null) return ru[m];
      const en = {
        'january': 31,
        'february': 28,
        'march': 31,
        'april': 30,
        'may': 31,
        'june': 30,
        'july': 31,
        'august': 31,
        'september': 30,
        'october': 31,
        'november': 30,
        'december': 31
      };
      if (en[m] != null) return en[m];
      return 31;
    }

    function formatYears(card) {
      const raw = (card.timeRaw || '').trim();
      const exact = (card.timeExact || '').trim();
      if (!raw && !exact) return '';

      const hasDash =
        raw.includes('-') || raw.includes('–') || raw.includes('—');

      let res = '';
      if (exact && raw && !hasDash) {
        // классический кейс: «14 августа 1385 г.»
        res = exact + ' ' + raw;
      } else if (raw) {
        res = raw;
      } else {
        // вдруг указана только точная дата без года
        res = exact;
      }

      const era = (card.era || '').trim();

      // Если указана ЭРА (кроме «н. э.»), то не добавляем «г.»/«гг.»,
      // чтобы получить, например, «14 век», а не «14 г. век».
      if (raw && (!era || era === 'н. э.')) {
        res += hasDash ? ' гг.' : ' г.';
      }

      if (era && era !== 'н. э.') {
        res += ' ' + era;
      }
      return res;
    }

    function formatFactDisplay(node, card) {
      const type = node.factType || 'assertion';
      if (type === 'assertion') {
        const subj = card.subject || node.name || '';
        return subj ? subj + ': ' + (card.text || '') : (card.text || '');
      }
      if (type === 'years') {
        const y = formatYears(card);
        const ev = card.event || '';
        const person = card.person || '';
        let prefix = '';
        if (person) prefix = person + ': ' + ev;
        else prefix = ev;
        return y ? prefix + ' — ' + y : prefix;
      }
      if (type === 'olist') {
        return '• ' + (card.text || '');
      }
      if (type === 'term') {
        return (card.word || '') + ' — ' + (card.definition || '');
      }
      return '';
    }

    function getCategorySubtreeNodeIds(nodeId) {
      const res = [];
      function walk(id) {
        res.push(id);
        const n = getNode(id);
        if (!n) return;
        (n.children || []).forEach(ch => walk(ch));
      }
      walk(nodeId);
      return res;
    }

    function getCategoryCharacteristics(nodeId) {
      return getCategorySubtreeNodeIds(nodeId)
        .map(id => getNode(id))
        .filter(n => n && n.type === 'characteristic');
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function pickRandom(arr, count, exceptVal) {
      const base = arr.filter(x => x !== exceptVal);
      return shuffle(base).slice(0, count);
    }

    // ===== RENDER: BREADCRUMB & TREE =====

    function buildBreadcrumb(nodeId) {
      const path = [];
      let n = getNode(nodeId);
      while (n) {
        path.unshift(n);
        if (!n.parentId) break;
        n = getNode(n.parentId);
      }
      breadcrumbEl.innerHTML = '';
      path.forEach((node, idx) => {
        if (idx > 0) {
          const sep = document.createElement('span');
          sep.textContent = '→';
          sep.className = 'breadcrumb-sep';
          breadcrumbEl.appendChild(sep);
        }
        const span = document.createElement('span');
        span.textContent = node.name || '(без названия)';
        if (idx < path.length - 1) {
          span.onclick = () => {
            currentNodeId = node.id;
            quizState = null;
            factsState = null;
            render();
          };
        } else {
          span.style.fontWeight = '500';
        }
        breadcrumbEl.appendChild(span);
      });
    }



// helpers for сворачивание/разворачивание иерархии
function isNodeExpanded(id, depth) {
  if (Object.prototype.hasOwnProperty.call(treeExpanded, id)) {
    return !!treeExpanded[id];
  }
  // по умолчанию корневые категории (depth = 0) раскрыты, вложенные — свернуты
  return depth === 0;
}

function setAllTreeExpanded(expanded) {
  Object.keys(state.nodes || {}).forEach(id => {
    const n = getNode(id);
    if (n && n.type === 'category') {
      treeExpanded[id] = !!expanded;
    }
  });
  renderTree();
}

function renderTree() {
  if (!treeRootEl) return;

  // Точка входа для навигации в левой панели:
  // sidebarViewNodeId — "текущая папка", в которой мы сейчас находимся.
  let viewNode = getNode(sidebarViewNodeId);
  if (!viewNode) {
    viewNode = getNode(state.rootId);
    sidebarViewNodeId = viewNode ? viewNode.id : null;
  }
  if (!viewNode) return;

  const isRoot = !viewNode.parentId;

  treeRootEl.innerHTML = '';

  // Шапка как в мессенджерах / проводнике:
  // слева — кнопка «назад», по центру — название текущего отсека.
  const header = document.createElement('div');
  header.className = 'hier-header';

  const left = document.createElement('div');
  left.className = 'hier-fx';

  if (!isRoot) {
    const backBtn = document.createElement('button');
    backBtn.type = 'button';
    backBtn.className = 'hier-fx-btn';
    backBtn.textContent = '← НАЗАД';
    backBtn.onclick = (e) => {
      e.stopPropagation();
      const parent = getNode(viewNode.parentId);
      if (parent) {
        sidebarViewNodeId = parent.id;
        currentNodeId = parent.id;
        quizState = null;
        factsState = null;
        render();
      }
    };
    left.appendChild(backBtn);
  } else {
    const label = document.createElement('div');
    label.textContent = 'ВСЕ ОТСЕКИ';
    left.appendChild(label);
  }

  const right = document.createElement('div');
  right.className = 'hier-fx-buttons';

  const title = document.createElement('div');
  title.className = 'hier-name';
  title.textContent = viewNode.name || 'Категории';

  right.appendChild(title);

  header.appendChild(left);
  header.appendChild(right);
  treeRootEl.appendChild(header);

  // Список "как в чате": показываем только прямых детей текущего отсека.
  const children = (viewNode.children || [])
    .map(id => getNode(id))
    .filter(n => !!n);

  if (!children.length) {
    const empty = document.createElement('div');
    empty.className = 'hint';
    empty.style.marginTop = '6px';
    empty.textContent = 'Здесь пока пусто. Создай подкатегорию или паттерн.';
    treeRootEl.appendChild(empty);
    return;
  }

  children.forEach(n => {
    const row = document.createElement('div');
    row.className = 'hier-row';
    row.dataset.id = n.id;
    row.setAttribute('draggable', 'true');

    if (n.type === 'category') row.classList.add('hier-row-category');
    else if (n.type === 'characteristic') row.classList.add('hier-row-characteristic');
    if (n.id === currentNodeId) row.classList.add('hier-row-current');

    // без лесенки, всё на одном уровне
    row.style.paddingLeft = '8px';

    const tag = document.createElement('div');
    tag.className = 'hier-tag';
    if (n.type === 'category') tag.textContent = '[cell]';
    else if (n.type === 'characteristic') tag.textContent = '[patt]';
    else tag.textContent = '[cell]';

    const name = document.createElement('div');
    name.className = 'hier-name';
    name.textContent = n.name || '(без названия)';

    row.appendChild(tag);
    row.appendChild(name);

    // маленький индикатор, что по категории можно "зайти внутрь"
    if (n.type === 'category') {
      const arrow = document.createElement('div');
      arrow.style.marginLeft = 'auto';
      arrow.style.fontSize = '11px';
      arrow.textContent = '▸';
      row.appendChild(arrow);
    }

    row.onclick = () => {
      currentNodeId = n.id;
      quizState = null;
      factsState = null;

      if (n.type === 'category') {
        sidebarViewNodeId = n.id; // заходим внутрь выбранного отсека
      }

      render();
    };

    treeRootEl.appendChild(row);
  });
}
function attachSectionToggles(wrapper) {
      const sections = wrapper.querySelectorAll('.section');
      sections.forEach(sec => {
        const header = sec.querySelector('.section-header');
        if (!header) return;
        header.addEventListener('click', (e) => {
          if (e.target.closest('button, input, select, textarea')) return;
          sec.classList.toggle('collapsed');
        });
      });
    }

    function renderDetails() {
      const node = getNode(currentNodeId);
      detailsRootEl.innerHTML = '';
      headerActionsEl.innerHTML = '';

      if (!node) {
        if (mainTitleTextEl) {
          mainTitleTextEl.textContent = 'АРХИВ';
        }
        detailsRootEl.innerHTML =
          '<div class="hint">Выбери категорию или характеристику слева.</div>';
        return;
      }

      // заголовок сверху: АРХИВОТСЕК / АРХИВПАТТЕРН
      if (mainTitleTextEl) {
        let titleText = 'АРХИВ';
        const name = (node.name || '(без названия)').toUpperCase();
        if (node.type === 'category') {
          titleText = 'ОТСЕК: ' + name;
        } else if (node.type === 'characteristic') {
          titleText = 'ПАТТЕРН: ' + name;
        }
        mainTitleTextEl.textContent = titleText;
      }

      if (node.id !== state.rootId) {
        const kindLabel = node.type === 'category' ? 'ОТСЕК' : 'ПАТТЕРН';

        const renameBtn = document.createElement('button');
        renameBtn.className = 'btn btn-sm btn-ghost btn-chip';
        renameBtn.textContent = 'ПЕРЕИМЕНОВАТЬ ' + kindLabel;
        renameBtn.onclick = () => {
          const newName = prompt('Новое название:', node.name || '');
          if (newName && newName.trim()) {
            renameNode(node.id, newName);
            render();
          }
        };
        headerActionsEl.appendChild(renameBtn);

        const delBtn = document.createElement('button');
        delBtn.className = 'btn btn-sm btn-danger btn-chip';
        delBtn.textContent = 'УДАЛИТЬ ' + kindLabel;
        delBtn.onclick = () => {
          const ok = confirm(
            'Удалить "' + (node.name || 'без названия') + '" и всё внутри?'
          );
          if (!ok) return;
          const parentId = node.parentId || state.rootId;
          deleteNodeAndDescendants(node.id);
          currentNodeId = parentId;
          render();
        };
        headerActionsEl.appendChild(delBtn);
      }

      if (node.type === 'category') {
        renderCategoryDetails(node);
      } else {
        renderCharacteristicDetails(node);
      }
    }

    function renderCategoryDetails(node) {
      const wrapper = document.createElement('div');

      // title row
      const titleRow = document.createElement('div');
      titleRow.className = 'title-row';

      const titleMain = document.createElement('div');
      titleMain.className = 'title-main';
      titleMain.innerHTML =
        '<span>' + (node.name || '(без названия)') + '</span>';
      titleRow.appendChild(titleMain);

      if (node.parentId === state.rootId && node.config) {
        const tag = document.createElement('div');
        tag.className = 'tag-config';
        let scopeText = node.config.scope === 'personal' ? 'Личное' : 'Предмет';
        let presetText = node.config.preset || '';
        if (node.config.scope === 'subject') {
          if (presetText === 'history') presetText = 'История';
          if (presetText === 'english') presetText = 'Английский';
        } else {
          if (presetText === 'notes') presetText = 'Заметки';
          if (presetText === 'ideas') presetText = 'Идеи';
        }
        tag.textContent = scopeText + (presetText ? ' · ' + presetText : '');
        titleRow.appendChild(tag);
      }

      wrapper.appendChild(titleRow);

      // summary line: facts & tests
      const chars = getCategoryCharacteristics(node.id);
      const factsCount = chars.reduce(
        (acc, ch) => acc + ((ch.cards || []).length),
        0
      );
      const summary = document.createElement('div');
      summary.className = 'hint';
      summary.textContent =
        'Отсек: ' +
        (node.name || '') +
        ' — ' +
        factsCount +
        ' фактов в ' +
        chars.length +
        ' характеристиках.';
      wrapper.appendChild(summary);

      // section: create inside
      const secCreate = document.createElement('div');
      secCreate.className = 'section';

      const secCreateHeader = document.createElement('div');
      secCreateHeader.className = 'section-header';
      secCreateHeader.innerHTML =
        '<div class="section-title">Зародить организм внутри отсека</div>';
      secCreate.appendChild(secCreateHeader);

      const secCreateBody = document.createElement('div');
      secCreateBody.className = 'section-body';

      const rowButtons = document.createElement('div');
      rowButtons.className = 'row';

      const btnCat = document.createElement('button');
      btnCat.className = 'btn btn-sm btn-ghost btn-full';
      btnCat.textContent = '+ Узел отсека';
      btnCat.onclick = () => openCreateDialog('category', node.id);

      const btnChar = document.createElement('button');
      btnChar.className = 'btn btn-sm btn-primary btn-full';
      btnChar.textContent = '+ Паттерн';
      btnChar.onclick = () => openCreateDialog('characteristic', node.id);

      const col1 = document.createElement('div');
      col1.appendChild(btnCat);
      const col2 = document.createElement('div');
      col2.appendChild(btnChar);

      rowButtons.appendChild(col1);
      rowButtons.appendChild(col2);

      secCreateBody.appendChild(rowButtons);
      secCreate.appendChild(secCreateBody);
      wrapper.appendChild(secCreate);

      // section: children
      const secChildren = document.createElement('div');
      secChildren.className = 'section';

      const secChHeader = document.createElement('div');
      secChHeader.className = 'section-header';
      const st = document.createElement('div');
      st.className = 'section-title';
      st.textContent = 'Содержимое категории';
      secChHeader.appendChild(st);
      secChildren.appendChild(secChHeader);

      const secChBody = document.createElement('div');
      secChBody.className = 'section-body';

      const childList = document.createElement('div');
      childList.className = 'child-list';

      if (!node.children || !node.children.length) {
        const p = document.createElement('div');
        p.className = 'hint';
        p.textContent =
          'Пока пусто. Сначала создай подкатегорию или характеристику.';
        childList.appendChild(p);
      } else {
        node.children.forEach(cid => {
          const ch = getNode(cid);
          if (!ch) return;
          const card = document.createElement('div');
          card.className = 'child-card';

          const name = document.createElement('div');
          name.className = 'child-name';
          name.textContent = ch.name || '(без названия)';

          const meta = document.createElement('div');
          meta.className = 'child-meta';

          const left = document.createElement('span');
          left.textContent = ch.type === 'category' ? 'Отсек' : 'Паттерн';

          const right = document.createElement('span');
          if (ch.type === 'category') {
            const subChars = getCategoryCharacteristics(ch.id);
            right.textContent = subChars.length + ' хар.';
          } else {
            const cnt = (ch.cards || []).length;
            let t = ch.factType || 'assertion';
            if (t === 'assertion') t = 'утв.';
            else if (t === 'years') t = 'годы';
            else if (t === 'olist') t = 'список';
            else if (t === 'term') t = 'слова';
            right.textContent = t + ' · ' + cnt;
          }
          meta.appendChild(left);
          meta.appendChild(right);

          card.appendChild(name);
          card.appendChild(meta);

          card.onclick = () => {
            currentNodeId = ch.id;
            render();
          };

          childList.appendChild(card);
        });
      }

      secChBody.appendChild(childList);
      secChildren.appendChild(secChBody);
      wrapper.appendChild(secChildren);

      // section: big tests
      const secTests = document.createElement('div');
      secTests.className = 'section';
      const secTestsHeader = document.createElement('div');
      secTestsHeader.className = 'section-header';
      secTestsHeader.innerHTML =
        '<div class="section-title">Тест по отсеку (учитывается всё что внутри)</div>';
      secTests.appendChild(secTestsHeader);

      const secTestsBody = document.createElement('div');
      secTestsBody.className = 'section-body';
      const hint = document.createElement('div');
      hint.className = 'hint';
      hint.textContent =
        'Берётся всё, что находится внутри этого отсека и его подотсеков. Кнопка становится активной, когда есть данные.';
      secTestsBody.appendChild(hint);

      const btnRow = document.createElement('div');
      btnRow.className = 'row';
      const types = [
        ['assertion', 'УТВЕРЖДЕНИЯ'],
        ['years', 'ГОДЫ'],
        ['olist', 'ОБЪЕКТНЫЕ СПИСКИ'],
        ['term', 'СЛОВА-ОПРЕДЕЛЕНИЯ']
      ];
      types.forEach(([type, label]) => {
        const col = document.createElement('div');
        const btn = document.createElement('button');
        btn.className = 'btn btn-sm btn-ghost btn-full';
        btn.textContent = label;

        const qs = buildQuestions('category', node.id, type);
        const hasQuestions = qs && qs.length;
        if (!hasQuestions) {
          btn.disabled = true;
        } else {
          if (qs.length) {
            btn.textContent = label + ' · ' + qs.length + ' вопр.';
          }
        }

        btn.onclick = () => startCategoryTest(node.id, type);
        col.appendChild(btn);
        btnRow.appendChild(col);
      });
      secTestsBody.appendChild(btnRow);
      secTests.appendChild(secTestsBody);
      wrapper.appendChild(secTests);

      detailsRootEl.appendChild(wrapper);
      attachSectionToggles(wrapper);
    }

    function renderCharacteristicDetails(node) {
      const wrapper = document.createElement('div');

      const titleRow = document.createElement('div');
      titleRow.className = 'title-row';

      const titleMain = document.createElement('div');
      titleMain.className = 'title-main characteristic';
      titleMain.textContent = node.name || '(без названия)';
      titleRow.appendChild(titleMain);
      wrapper.appendChild(titleRow);

      const parent = getNode(node.parentId);

      // SECTION: Тип факта
      const secType = document.createElement('div');
      secType.className = 'section';

      let ft = node.factType || 'assertion';
      const parentName = parent ? (parent.name || '') : '';

      const patternLabelMap = {
        assertion: 'ФАКТЫ',
        years: 'ГОДА',
        olist: 'ОБЪЕКТНЫЕ СПИСКИ',
        term: 'СЛОВА-ОПРЕДЕЛЕНИЯ'
      };
      const patternLabel = patternLabelMap[ft] || '';

      const secTypeHeader = document.createElement('div');
      secTypeHeader.className = 'section-header';
      secTypeHeader.innerHTML =
        '<div class="section-title">ТИП ПАТТЕРНА: ' + patternLabel + '</div>';
      secType.appendChild(secTypeHeader);

      const secTypeBody = document.createElement('div');
      secTypeBody.className = 'section-body';

      const rowType = document.createElement('div');
      rowType.className = 'row';

      const colInfo = document.createElement('div');
      const h1 = document.createElement('div');
      h1.className = 'hint';
      h1.textContent = parentName
        ? 'Отсек: ' + parentName
        : 'Без отсека';
      colInfo.appendChild(h1);

      const h2 = document.createElement('div');
      h2.className = 'hint';
      h2.textContent =
        'Тип паттерна выбирается при создании и здесь только отображается.';
      colInfo.appendChild(h2);

      rowType.appendChild(colInfo);
      secTypeBody.appendChild(rowType);
      secType.appendChild(secTypeBody);
      wrapper.appendChild(secType);

      // SECTION: Воспользоваться паттерном
      const secUse = document.createElement('div');
      secUse.className = 'section';
      const secUseHeader = document.createElement('div');
      secUseHeader.className = 'section-header';
      secUseHeader.innerHTML =
        '<div class="section-title">Воспользоваться паттерном</div>';
      secUse.appendChild(secUseHeader);

      const secUseBody = document.createElement('div');
      secUseBody.className = 'section-body';

      const toolbar = document.createElement('div');
      toolbar.className = 'row-xs';

      const btnViewFacts = document.createElement('button');
      btnViewFacts.className = 'btn btn-sm btn-ghost';
      btnViewFacts.textContent = 'КАРТОЧКИ';
      btnViewFacts.onclick = () => startFactsView(node.id);
      toolbar.appendChild(btnViewFacts);

      const tests = [
        ['assertion', 'ТЕСТ: УТВЕРЖДЕНИЯ'],
        ['years', 'ТЕСТ: ГОДЫ'],
        ['olist', 'ТЕСТ: СПИСКИ'],
        ['term', 'ТЕСТ: ТЕРМИНЫ']
      ];
      tests.forEach(([t, label]) => {
        const b = document.createElement('button');
        b.className = 'btn btn-sm btn-ghost btn-chip';
        b.textContent = label;
        b.onclick = () => startCharacteristicTest(node.id, t);
        toolbar.appendChild(b);
      });

      secUseBody.appendChild(toolbar);
      secUse.appendChild(secUseBody);
      wrapper.appendChild(secUse);
// SECTION: Добавление факта
      const secAdd = document.createElement('div');
      secAdd.className = 'section';
      const secAddHeader = document.createElement('div');
      secAddHeader.className = 'section-header';
      secAddHeader.innerHTML =
        '<div class="section-title">Зародить организм внутри паттерна</div>';
      secAdd.appendChild(secAddHeader);

      const secAddBody = document.createElement('div');
      secAddBody.className = 'section-body';

      if (node.factType === 'assertion') {
        const r1 = document.createElement('div');
        r1.className = 'form-row';
        const l1 = document.createElement('div');
        l1.className = 'form-label';
        l1.textContent = 'Кто / что? (необязательно)';
        const c1 = document.createElement('div');
        const i1 = document.createElement('input');
        i1.className = 'form-input';
        i1.placeholder = 'Например: «Минск» или «Яглонский»';
        if (parent && parent.name) {
          i1.value = parent.name;
        }
        c1.appendChild(i1);
        r1.appendChild(l1);
        r1.appendChild(c1);

        const r2 = document.createElement('div');
        r2.className = 'form-row';
        const l2 = document.createElement('div');
        l2.className = 'form-label';
        l2.textContent = 'Утверждение';
        const c2 = document.createElement('div');
        const t2 = document.createElement('textarea');
        t2.className = 'form-textarea';
        t2.placeholder = 'Краткое утверждение, по которому потом будет вопрос.';
        c2.appendChild(t2);
        r2.appendChild(l2);
        r2.appendChild(c2);

        const rowBtns = document.createElement('div');
        rowBtns.style.marginTop = '6px';
        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn btn-sm btn-primary';
        btnAdd.textContent = 'Добавить утверждение';
        btnAdd.onclick = () => {
          addAssertionCard(node.id, t2.value, i1.value);
          t2.value = '';
          i1.value = '';
          render();
        };
        rowBtns.appendChild(btnAdd);

        secAddBody.appendChild(r1);
        secAddBody.appendChild(r2);
        secAddBody.appendChild(rowBtns);
      } else if (node.factType === 'years') {
        const r1 = document.createElement('div');
        r1.className = 'form-row';
        const l1 = document.createElement('div');
        l1.className = 'form-label';
        l1.textContent = 'Событие';
        const c1 = document.createElement('div');
        const i1 = document.createElement('input');
        i1.className = 'form-input';
        i1.placeholder = 'Например: «Убийство Вещи»';
        c1.appendChild(i1);
        r1.appendChild(l1);
        r1.appendChild(c1);

        const r2 = document.createElement('div');
        r2.className = 'form-row';
        const l2 = document.createElement('div');
        l2.className = 'form-label';
        l2.textContent = 'Год / период';
        const c2 = document.createElement('div');
        const i2 = document.createElement('input');
        i2.className = 'form-input';
        i2.placeholder = 'Например: «1067» или «1359-2053»';
        i2.addEventListener('input', () => {
          i2.value = i2.value.replace(/[^0-9\-–—]/g, '');
        });
        c2.appendChild(i2);
        r2.appendChild(l2);
        r2.appendChild(c2);

        const r3 = document.createElement('div');
        r3.className = 'form-row';
        const l3 = document.createElement('div');
        l3.className = 'form-label';
        l3.textContent = 'Точная дата (необязательно)';
        const c3 = document.createElement('div');
        const dateWrap = document.createElement('div');
        dateWrap.className = 'date-exact-row';
        const i3day = document.createElement('input');
        i3day.className = 'form-input';
        i3day.type = 'number';
        i3day.min = '1';
        i3day.max = '31';
        i3day.placeholder = '32';
        const i3month = document.createElement('input');
        i3month.className = 'form-input';
        i3month.placeholder = 'августа';
        i3month.addEventListener('input', () => {
          i3month.value = i3month.value.replace(/[0-9]/g, '');
          const maxDay = getMaxDaysForMonth(i3month.value.trim());
          i3day.max = String(maxDay);
          const cur = Number(i3day.value);
          if (cur > maxDay) {
            i3day.value = maxDay ? String(maxDay) : '';
          }
        });

        i3day.addEventListener('input', () => {
          const month = i3month.value.trim();
          const maxDay = month ? getMaxDaysForMonth(month) : 31;
          let val = Number(i3day.value);
          if (!val) {
            i3day.value = '';
            return;
          }
          if (val < 1) val = 1;
          if (val > maxDay) val = maxDay;
          i3day.value = String(val);
        });

        dateWrap.appendChild(i3day);
        dateWrap.appendChild(i3month);
        c3.appendChild(dateWrap);
        r3.appendChild(l3);
        r3.appendChild(c3);

        const r4 = document.createElement('div');
        r4.className = 'form-row';
        const l4 = document.createElement('div');
        l4.className = 'form-label';
        l4.textContent = 'Эра';
        const c4 = document.createElement('div');
        const i4 = document.createElement('input');
        i4.className = 'form-input';
        i4.placeholder = 'Например: «н. э.» (оставь пустым, если речь идет о годах нашей эры)';
        c4.appendChild(i4);
        r4.appendChild(l4);
        r4.appendChild(c4);

        const r5 = document.createElement('div');
        r5.className = 'form-row';
        const l5 = document.createElement('div');
        l5.className = 'form-label';
        l5.textContent = 'Персона (необязательно)';
        const c5 = document.createElement('div');
        const i5 = document.createElement('input');
        i5.className = 'form-input';
        i5.placeholder = 'Например: «Скарина»';
        if (parent && parent.name) {
          i5.value = parent.name;
        }
        c5.appendChild(i5);
        r5.appendChild(l5);
        r5.appendChild(c5);

        const rowBtns = document.createElement('div');
        rowBtns.style.marginTop = '6px';
        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn btn-sm btn-primary';
        btnAdd.textContent = 'Добавить событие';
        btnAdd.onclick = () => {
          const raw = (i2.value || '').trim();
          if (!raw) {
            alert('Сначала укажи год или период.');
            return;
          }
          if (!isValidYearOrPeriod(raw)) {
            alert('Год / период должен быть в формате «1385» или «1385-1386».');
            return;
          }

          const day = i3day.value.trim();
          const month = i3month.value.trim();

          if (day && !month) {
            alert('Если указываешь число дня, укажи и месяц.');
            return;
          }

          if (day) {
            const maxDay = month ? getMaxDaysForMonth(month) : 31;
            const dayNum = Number(day);
            if (dayNum < 1 || dayNum > maxDay) {
              alert('В этом месяце не может быть дня «' + day + '». Максимум: ' + maxDay + '.');
              return;
            }
          }

          let exact = '';
          if (day || month) {
            exact = day && month ? (day + ' ' + month) : (day || month);
          }
          addYearsCard(node.id, i1.value, raw, i4.value, i5.value, exact);
          i1.value = '';
          i2.value = '';
          i3day.value = '';
          i3month.value = '';
          i4.value = '';
          i5.value = '';
          render();
        };
        rowBtns.appendChild(btnAdd);

        secAddBody.appendChild(r1);
        secAddBody.appendChild(r2);
        secAddBody.appendChild(r3);
        secAddBody.appendChild(r4);
        secAddBody.appendChild(r5);
        secAddBody.appendChild(rowBtns);
      } else if (node.factType === 'olist') {
        const r1 = document.createElement('div');
        r1.className = 'form-row';
        const l1 = document.createElement('div');
        l1.className = 'form-label';
        l1.textContent = 'Пункт списка';
        const c1 = document.createElement('div');
        const i1 = document.createElement('textarea');
        i1.className = 'form-textarea';
        i1.placeholder =
          'Каждый пункт списка — отдельный факт. Например: «Столица — Минск».';
        c1.appendChild(i1);
        r1.appendChild(l1);
        r1.appendChild(c1);

        const rowBtns = document.createElement('div');
        rowBtns.style.marginTop = '6px';
        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn btn-sm btn-primary';
        btnAdd.textContent = 'Добавить пункт';
        btnAdd.onclick = () => {
          addOListItem(node.id, i1.value);
          i1.value = '';
          render();
        };
        rowBtns.appendChild(btnAdd);

        secAddBody.appendChild(r1);
        secAddBody.appendChild(rowBtns);
      } else if (node.factType === 'term') {
        const r1 = document.createElement('div');
        r1.className = 'form-row';
        const l1 = document.createElement('div');
        l1.className = 'form-label';
        l1.textContent = 'Слово / термин';
        const c1 = document.createElement('div');
        const i1 = document.createElement('input');
        i1.className = 'form-input';
        i1.placeholder = 'Например: «Референдум»';
        c1.appendChild(i1);
        r1.appendChild(l1);
        r1.appendChild(c1);

        const r2 = document.createElement('div');
        r2.className = 'form-row';
        const l2 = document.createElement('div');
        l2.className = 'form-label';
        l2.textContent = 'Определение';
        const c2 = document.createElement('div');
        const i2 = document.createElement('textarea');
        i2.className = 'form-textarea';
        i2.placeholder = 'Краткое, но понятное определение.';
        c2.appendChild(i2);
        r2.appendChild(l2);
        r2.appendChild(c2);

        const rowBtns = document.createElement('div');
        rowBtns.style.marginTop = '6px';
        const btnAdd = document.createElement('button');
        btnAdd.className = 'btn btn-sm btn-primary';
        btnAdd.textContent = 'Добавить термин';
        btnAdd.onclick = () => {
          addTermCard(node.id, i1.value, i2.value);
          i1.value = '';
          i2.value = '';
          render();
        };
        rowBtns.appendChild(btnAdd);

        secAddBody.appendChild(r1);
        secAddBody.appendChild(r2);
        secAddBody.appendChild(rowBtns);
      }

      secAdd.appendChild(secAddBody);
      wrapper.appendChild(secAdd);

      // SECTION: Список фактов и тестов
      const secFacts = document.createElement('div');
      secFacts.className = 'section';
      const secFactsHeader = document.createElement('div');
      secFactsHeader.className = 'section-header';
      secFactsHeader.innerHTML =
        '<div class="section-title">Существующие факты внутри паттерна</div>';
      secFacts.appendChild(secFactsHeader);

      const secFactsBody = document.createElement('div');
      secFactsBody.className = 'section-body';

            const cards = node.cards || [];
      if (!cards.length) {
        const p = document.createElement('div');
        p.className = 'hint';
        p.textContent =
          'Фактов пока нет. Добавь хотя бы пару выше, чтобы начать тренироваться.';
        secFactsBody.appendChild(p);
      } else {
        const table = document.createElement('table');
        table.className = 'card-table';
        const thead = document.createElement('thead');
        const trh = document.createElement('tr');
        ['Факт', 'Управление', 'Порядок'].forEach(h => {
          const th = document.createElement('th');
          th.textContent = h;
          trh.appendChild(th);
        });
        thead.appendChild(trh);
        table.appendChild(thead);
        const tbody = document.createElement('tbody');

        cards.forEach((card, index) => {
          const tr = document.createElement('tr');
          const tdText = document.createElement('td');
          const span = document.createElement('div');
          span.className = 'card-display';
          span.textContent = formatFactDisplay(node, card);
          tdText.appendChild(span);

          const tdActions = document.createElement('td');
          const btns = document.createElement('div');
          btns.className = 'card-table-actions';

          const btnEdit = document.createElement('button');
          btnEdit.className = 'btn btn-sm btn-ghost';
          btnEdit.textContent = 'Редактировать';

          const btnDel = document.createElement('button');
          btnDel.className = 'btn btn-sm btn-danger';
          btnDel.textContent = 'Удалить';

          btnDel.onclick = () => {
            const ok = confirm('Удалить этот факт?');
            if (!ok) return;
            deleteCard(node.id, card.id);
            render();
          };

          btnEdit.onclick = () => {
            // не даём открыть несколько форм редактирования для одного факта
            const existing = tdText.querySelector('.fact-edit-container');
            if (existing) existing.remove();

            const editContainer = document.createElement('div');
            editContainer.className = 'fact-edit-container';
            editContainer.style.marginTop = '6px';
            const hr = document.createElement('hr');
            hr.style.border = 'none';
            hr.style.borderTop = '1px dashed rgba(148,163,184,0.4)';
            hr.style.margin = '6px 0';
            editContainer.appendChild(hr);

            const form = document.createElement('div');
            form.className = 'section-body';

            if (node.factType === 'assertion') {
              const r1 = document.createElement('div');
              r1.className = 'form-row';
              const l1 = document.createElement('div');
              l1.className = 'form-label';
              l1.textContent = 'Кто / что?';
              const c1 = document.createElement('div');
              const i1 = document.createElement('input');
              i1.className = 'form-input';
              i1.value = card.subject || '';
              c1.appendChild(i1);
              r1.appendChild(l1);
              r1.appendChild(c1);

              const r2 = document.createElement('div');
              r2.className = 'form-row';
              const l2 = document.createElement('div');
              l2.className = 'form-label';
              l2.textContent = 'Утверждение';
              const c2 = document.createElement('div');
              const i2 = document.createElement('textarea');
              i2.className = 'form-textarea';
              i2.value = card.text || '';
              c2.appendChild(i2);
              r2.appendChild(l2);
              r2.appendChild(c2);

              form.appendChild(r1);
              form.appendChild(r2);

              const rowBtns = document.createElement('div');
              rowBtns.className = 'row';
              const colSave = document.createElement('div');
              const colCancel = document.createElement('div');

              const btnSave = document.createElement('button');
              btnSave.className = 'btn btn-sm btn-primary btn-full';
              btnSave.textContent = 'Сохранить';
              btnSave.onclick = () => {
                updateCard(node.id, card.id, {
                  subject: i1.value,
                  text: i2.value
                });
                render();
              };

              const btnCancelEdit = document.createElement('button');
              btnCancelEdit.className = 'btn btn-sm btn-ghost btn-full';
              btnCancelEdit.textContent = 'Отмена';
              btnCancelEdit.onclick = () => {
                editContainer.remove();
              };

              colSave.appendChild(btnSave);
              colCancel.appendChild(btnCancelEdit);
              rowBtns.appendChild(colSave);
              rowBtns.appendChild(colCancel);
              form.appendChild(rowBtns);
            } else if (node.factType === 'years') {
              const inputs = {};

              // Событие
              {
                const r = document.createElement('div');
                r.className = 'form-row';
                const l = document.createElement('div');
                l.className = 'form-label';
                l.textContent = 'Событие';
                const c = document.createElement('div');
                const inp = document.createElement('input');
                inp.className = 'form-input';
                inp.value = card.event || '';
                c.appendChild(inp);
                r.appendChild(l);
                r.appendChild(c);
                form.appendChild(r);
                inputs.event = inp;
              }

              // Год / период
              {
                const r = document.createElement('div');
                r.className = 'form-row';
                const l = document.createElement('div');
                l.className = 'form-label';
                l.textContent = 'Год / период';
                const c = document.createElement('div');
                const inp = document.createElement('input');
                inp.className = 'form-input';
                inp.value = card.timeRaw || '';
                inp.addEventListener('input', () => {
                  inp.value = inp.value.replace(/[^0-9\-–—]/g, '');
                });
                c.appendChild(inp);
                r.appendChild(l);
                r.appendChild(c);
                form.appendChild(r);
                inputs.timeRaw = inp;
              }

              // Точная дата (необязательно): день + месяц
              const rExact = document.createElement('div');
              rExact.className = 'form-row';
              const lExact = document.createElement('div');
              lExact.className = 'form-label';
              lExact.textContent = 'Точная дата (необязательно)';
              const cExact = document.createElement('div');
              const wrapExact = document.createElement('div');
              wrapExact.className = 'date-exact-row';

              const inpDay = document.createElement('input');
              inpDay.className = 'form-input';
              inpDay.type = 'number';
              inpDay.min = '1';
              inpDay.max = '31';
              inpDay.placeholder = '32';

              const inpMonth = document.createElement('input');
              inpMonth.className = 'form-input';
              inpMonth.placeholder = 'августа';

              inpMonth.addEventListener('input', () => {
                inpMonth.value = inpMonth.value.replace(/[0-9]/g, '');
                const maxDay = getMaxDaysForMonth(inpMonth.value.trim());
                inpDay.max = String(maxDay);
                const cur = Number(inpDay.value);
                if (cur > maxDay) {
                  inpDay.value = maxDay ? String(maxDay) : '';
                }
              });

              inpDay.addEventListener('input', () => {
                const month = inpMonth.value.trim();
                const maxDay = month ? getMaxDaysForMonth(month) : 31;
                let val = Number(inpDay.value);
                if (!val) {
                  inpDay.value = '';
                  return;
                }
                if (val < 1) val = 1;
                if (val > maxDay) val = maxDay;
                inpDay.value = String(val);
              });

              if (card.timeExact) {
                const parts = String(card.timeExact).split(' ');
                if (parts.length > 0) inpDay.value = parts[0];
                if (parts.length > 1) inpMonth.value = parts.slice(1).join(' ');
              }

              wrapExact.appendChild(inpDay);
              wrapExact.appendChild(inpMonth);
              cExact.appendChild(wrapExact);
              rExact.appendChild(lExact);
              rExact.appendChild(cExact);
              form.appendChild(rExact);

              // Эра
              {
                const r = document.createElement('div');
                r.className = 'form-row';
                const l = document.createElement('div');
                l.className = 'form-label';
                l.textContent = 'Эра';
                const c = document.createElement('div');
                const inp = document.createElement('input');
                inp.className = 'form-input';
                inp.value = card.era || '';
                c.appendChild(inp);
                r.appendChild(l);
                r.appendChild(c);
                form.appendChild(r);
                inputs.era = inp;
              }

              // Персона
              {
                const r = document.createElement('div');
                r.className = 'form-row';
                const l = document.createElement('div');
                l.className = 'form-label';
                l.textContent = 'Персона (если не тот о ком идет речь - замени)';
                const c = document.createElement('div');
                const inp = document.createElement('input');
                inp.className = 'form-input';
                inp.value = card.person || '';
                c.appendChild(inp);
                r.appendChild(l);
                r.appendChild(c);
                form.appendChild(r);
                inputs.person = inp;
              }

              const rowBtns = document.createElement('div');
              rowBtns.className = 'row';
              const colSave = document.createElement('div');
              const colCancel = document.createElement('div');

              const btnSave = document.createElement('button');
              btnSave.className = 'btn btn-sm btn-primary btn-full';
              btnSave.textContent = 'Сохранить';
              btnSave.onclick = () => {
                const raw = (inputs.timeRaw.value || '').trim();
                if (!raw) {
                  alert('Сначала укажи год или период.');
                  return;
                }
                if (!isValidYearOrPeriod(raw)) {
                  alert('Год / период должен быть в формате «1385» или «1385-1386».');
                  return;
                }

                const day = inpDay.value.trim();
                const month = inpMonth.value.trim();

                if (day && !month) {
                  alert('Если указываешь число дня, укажи и месяц.');
                  return;
                }

                if (day) {
                  const maxDay = month ? getMaxDaysForMonth(month) : 31;
                  const dayNum = Number(day);
                  if (dayNum < 1 || dayNum > maxDay) {
                    alert('В этом месяце не может быть дня «' + day + '». Максимум: ' + maxDay + '.');
                    return;
                  }
                }

                let exact = '';
                if (day || month) {
                  exact = day && month ? (day + ' ' + month) : (day || month);
                }
                updateCard(node.id, card.id, {
                  event: inputs.event.value,
                  timeRaw: raw,
                  era: inputs.era.value,
                  person: inputs.person.value,
                  timeExact: exact
                });
                render();
              };

              const btnCancelEdit = document.createElement('button');
              btnCancelEdit.className = 'btn btn-sm btn-ghost btn-full';
              btnCancelEdit.textContent = 'Отмена';
              btnCancelEdit.onclick = () => {
                editContainer.remove();
              };

              colSave.appendChild(btnSave);
              colCancel.appendChild(btnCancelEdit);
              rowBtns.appendChild(colSave);
              rowBtns.appendChild(colCancel);
              form.appendChild(rowBtns);
            } else if (node.factType === 'olist') {
              const rowF = document.createElement('div');
              rowF.className = 'form-row';
              const l = document.createElement('div');
              l.className = 'form-label';
              l.textContent = 'Пункт списка';
              const c = document.createElement('div');
              const t = document.createElement('textarea');
              t.className = 'form-textarea';
              t.value = card.text || '';
              c.appendChild(t);
              rowF.appendChild(l);
              rowF.appendChild(c);
              form.appendChild(rowF);

              const rowBtns = document.createElement('div');
              rowBtns.className = 'row';
              const colSave = document.createElement('div');
              const colCancel = document.createElement('div');

              const btnSave = document.createElement('button');
              btnSave.className = 'btn btn-sm btn-primary btn-full';
              btnSave.textContent = 'Сохранить';
              btnSave.onclick = () => {
                updateCard(node.id, card.id, { text: t.value });
                render();
              };

              const btnCancelEdit = document.createElement('button');
              btnCancelEdit.className = 'btn btn-sm btn-ghost btn-full';
              btnCancelEdit.textContent = 'Отмена';
              btnCancelEdit.onclick = () => {
                editContainer.remove();
              };

              colSave.appendChild(btnSave);
              colCancel.appendChild(btnCancelEdit);
              rowBtns.appendChild(colSave);
              rowBtns.appendChild(colCancel);
              form.appendChild(rowBtns);
            } else if (node.factType === 'term') {
              const r1 = document.createElement('div');
              r1.className = 'form-row';
              const l1 = document.createElement('div');
              l1.className = 'form-label';
              l1.textContent = 'Слово / термин';
              const c1 = document.createElement('div');
              const i1 = document.createElement('input');
              i1.className = 'form-input';
              i1.value = card.word || '';
              c1.appendChild(i1);
              r1.appendChild(l1);
              r1.appendChild(c1);

              const r2 = document.createElement('div');
              r2.className = 'form-row';
              const l2 = document.createElement('div');
              l2.className = 'form-label';
              l2.textContent = 'Определение';
              const c2 = document.createElement('div');
              const i2 = document.createElement('textarea');
              i2.className = 'form-textarea';
              i2.value = card.definition || '';
              c2.appendChild(i2);
              r2.appendChild(l2);
              r2.appendChild(c2);

              form.appendChild(r1);
              form.appendChild(r2);

              const rowBtns = document.createElement('div');
              rowBtns.className = 'row';
              const colSave = document.createElement('div');
              const colCancel = document.createElement('div');

              const btnSave = document.createElement('button');
              btnSave.className = 'btn btn-sm btn-primary btn-full';
              btnSave.textContent = 'Сохранить';
              btnSave.onclick = () => {
                updateCard(node.id, card.id, {
                  word: i1.value,
                  definition: i2.value
                });
                render();
              };

              const btnCancelEdit = document.createElement('button');
              btnCancelEdit.className = 'btn btn-sm btn-ghost btn-full';
              btnCancelEdit.textContent = 'Отмена';
              btnCancelEdit.onclick = () => {
                editContainer.remove();
              };

              colSave.appendChild(btnSave);
              colCancel.appendChild(btnCancelEdit);
              rowBtns.appendChild(colSave);
              rowBtns.appendChild(colCancel);
              form.appendChild(rowBtns);
            }

            editContainer.appendChild(form);
            tdText.appendChild(editContainer);
          };

          btns.appendChild(btnEdit);
          btns.appendChild(btnDel);
          tdActions.appendChild(btns);

          tr.appendChild(tdText);
          tr.appendChild(tdActions);

          const tdOrder = document.createElement('td');
          const orderWrap = document.createElement('div');
          orderWrap.className = 'card-order-controls';

          const btnUp = document.createElement('button');
          btnUp.className = 'btn btn-sm btn-ghost';
          btnUp.textContent = '↑';
          if (index === 0) btnUp.disabled = true;
          btnUp.onclick = () => {
            moveCard(node.id, card.id, 'up');
            render();
          };

          const btnDown = document.createElement('button');
          btnDown.className = 'btn btn-sm btn-ghost';
          btnDown.textContent = '↓';
          if (index === cards.length - 1) btnDown.disabled = true;
          btnDown.onclick = () => {
            moveCard(node.id, card.id, 'down');
            render();
          };

          orderWrap.appendChild(btnUp);
          orderWrap.appendChild(btnDown);
          tdOrder.appendChild(orderWrap);
          tr.appendChild(tdOrder);

          tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        secFactsBody.appendChild(table);
      }

      secFacts.appendChild(secFactsBody);
      wrapper.appendChild(secFacts);

      detailsRootEl.appendChild(wrapper);
      attachSectionToggles(wrapper);
    }

    // ===== FACTS OVERLAY =====

    function startFactsView(nodeId) {
      const node = getNode(nodeId);
      if (!node || node.type !== 'characteristic') return;
      const items = [];
      (node.cards || []).forEach(c => {
        items.push({
          title: node.name || '',
          text: formatFactDisplay(node, c)
        });
      });

      factsState = {
        nodeId,
        items,
        currentIndex: 0
      };

      factsHeaderTitleEl.textContent = 'Факты: ' + (node.name || '');
      renderFacts();
      document.getElementById('appRoot').style.display = 'none';
      factsScreenEl.style.display = 'flex';
    }

    function renderFacts() {
      if (!factsState) return;
      const { items, currentIndex } = factsState;
      const total = items.length;
      if (!total) return;
      const item = items[currentIndex];
      factsTextEl.textContent = item.text || '';
      factsProgressEl.textContent = 'Факт ' + (currentIndex + 1) + ' из ' + total;
      factsCountEl.textContent = 'Всего фактов: ' + total;
      btnFactPrev.disabled = currentIndex === 0;
      btnFactNext.disabled = currentIndex === total - 1;
    }

    function exitFacts() {
      factsState = null;
      factsScreenEl.style.display = 'none';
      document.getElementById('appRoot').style.display = 'grid';
    }

    // ===== QUIZ QUESTION GENERATION =====

    function buildQuestionsForAssertion(scope, scopeId) {
      let chars = [];
      if (scope === 'category') {
        chars = getCategoryCharacteristics(scopeId).filter(
          ch => (ch.factType || 'assertion') === 'assertion'
        );
      } else {
        const n = getNode(scopeId);
        if (
          n &&
          n.type === 'characteristic' &&
          (n.factType || 'assertion') === 'assertion'
        )
          chars = [n];
      }
      const pairs = [];
      chars.forEach(ch => {
        (ch.cards || []).forEach(c => pairs.push({ node: ch, card: c }));
      });
      if (pairs.length < 2) return [];

      const subjects = [
        ...new Set(
          pairs
            .map(p => p.card.subject || p.node.name)
            .filter(Boolean)
        )
      ];
      if (subjects.length < 2) return [];

      const questions = [];
      pairs.forEach(p => {
        const node = p.node;
        const card = p.card;
        const subj = card.subject || node.name || '';
        const text = card.text || '';
        if (!subj || !text) return;

        const wrong = pickRandom(subjects, 3, subj);
        const options = shuffle([subj, ...wrong]).map(o => ({ id: o, text: o }));

        questions.push({
          type: 'single',
          testType: 'assertion',
          questionText:
            text + '\n\nКто/что относится к этому утверждению?',
          options,
          correctIds: [subj],
          correctAnswerText: subj
        });
      });
      return questions;
    }

    function buildQuestionsForYears(scope, scopeId) {
      let chars = [];
      if (scope === 'category') {
        chars = getCategoryCharacteristics(scopeId).filter(
          ch => (ch.factType || 'assertion') === 'years'
        );
      } else {
        const n = getNode(scopeId);
        if (
          n &&
          n.type === 'characteristic' &&
          (n.factType || 'assertion') === 'years'
        )
          chars = [n];
      }

      const pairs = [];
      chars.forEach(ch => {
        (ch.cards || []).forEach(c => {
          if (c.timeRaw) pairs.push({ node: ch, card: c });
        });
      });
      if (pairs.length < 2) return [];

      const allTimeLabels = pairs.map(p => formatYears(p.card)).filter(Boolean);

      const questions = [];
      pairs.forEach(p => {
        const card = p.card;
        const label = formatYears(card);
        if (!label) return;
        const ev = (card.event || '').trim();
        const person = (card.person || '').trim();
        let q;
        if (person) q = 'В каком году ' + person + ' ' + ev + '?';
        else q = 'В каком году произошло событие:\n' + ev;

        const wrong = pickRandom(allTimeLabels, 3, label);
        const options = shuffle([label, ...wrong]).map(o => ({ id: o, text: o }));

        questions.push({
          type: 'single',
          testType: 'years',
          questionText: q,
          options,
          correctIds: [label],
          correctAnswerText: label
        });
      });
      return questions;
    }

    function buildQuestionsForOList(scope, scopeId) {
      let chars = [];
      if (scope === 'category') {
        chars = getCategoryCharacteristics(scopeId).filter(
          ch => (ch.factType || 'assertion') === 'olist'
        );
      } else {
        const n = getNode(scopeId);
        if (
          n &&
          n.type === 'characteristic' &&
          (n.factType || 'assertion') === 'olist'
        )
          chars = [n];
      }

      const lists = chars
        .map(ch => ({ node: ch, cards: ch.cards || [] }))
        .filter(x => x.cards.length);
      if (!lists.length) return [];

      const allItems = [];
      lists.forEach(({ node, cards }) => {
        cards.forEach(c => allItems.push({ node, card: c }));
      });

      const questions = [];
      lists.forEach(({ node, cards }) => {
        if (!cards.length) return;
        const topic = node.name || 'Список';

        const correctOptions = cards.map(c => ({
          id: c.id,
          text: c.text || ''
        }));

        const wrongPool = allItems.filter(it => it.node.id !== node.id);
        const wrongOptions = shuffle(wrongPool)
          .slice(0, Math.max(2, correctOptions.length))
          .map(it => ({
            id: it.card.id + '_wrong_' + it.node.id,
            text: it.card.text || ''
          }));

        const options = shuffle([...correctOptions, ...wrongOptions]);
        const correctIds = correctOptions.map(o => o.id);

        questions.push({
          type: 'multi',
          testType: 'olist',
          questionText:
            'Выбери ВСЕ пункты, относящиеся к теме:\n«' + topic + '»',
          options,
          correctIds,
          correctAnswerText: correctOptions.map(o => o.text).join('\n')
        });
      });

      return questions;
    }

    function buildQuestionsForTerm(scope, scopeId) {
      let chars = [];
      if (scope === 'category') {
        chars = getCategoryCharacteristics(scopeId).filter(
          ch => (ch.factType || 'assertion') === 'term'
        );
      } else {
        const n = getNode(scopeId);
        if (
          n &&
          n.type === 'characteristic' &&
          (n.factType || 'assertion') === 'term'
        )
          chars = [n];
      }

      const pairs = [];
      chars.forEach(ch => {
        (ch.cards || []).forEach(c => pairs.push({ node: ch, card: c }));
      });
      if (pairs.length < 2) return [];

      const allDefs = pairs.map(p => p.card.definition).filter(Boolean);

      const questions = [];
      pairs.forEach(p => {
        const card = p.card;
        const word = (card.word || '').trim();
        const def = (card.definition || '').trim();
        if (!word || !def) return;

        const wrong = pickRandom(allDefs, 3, def);
        const options = shuffle([def, ...wrong]).map(o => ({ id: o, text: o }));

        questions.push({
          type: 'single',
          testType: 'term',
          questionText: 'Что означает слово: «' + word + '»?',
          options,
          correctIds: [def],
          correctAnswerText: def
        });
      });
      return questions;
    }

    function buildQuestions(scope, scopeId, testType) {
      if (testType === 'assertion')
        return buildQuestionsForAssertion(scope, scopeId);
      if (testType === 'years') return buildQuestionsForYears(scope, scopeId);
      if (testType === 'olist') return buildQuestionsForOList(scope, scopeId);
      if (testType === 'term') return buildQuestionsForTerm(scope, scopeId);
      return [];
    }

    // ===== QUIZ OVERLAY LOGIC =====

    function startCategoryTest(categoryId, testType) {
      const node = getNode(categoryId);
      if (!node || node.type !== 'category') return;
      const questions = buildQuestions('category', categoryId, testType);
      if (!questions || !questions.length) {
        alert('Недостаточно данных для этого теста.');
        return;
      }
      quizState = {
        scope: 'category',
        scopeId: categoryId,
        testType,
        questions: shuffle(questions),
        currentIndex: 0,
        total: questions.length,
        correctCount: 0
      };
      quizHeaderTitleEl.textContent = 'Тест по категории: ' + (node.name || '');
      showQuiz();
    }

    function startCharacteristicTest(charId, testType) {
      const node = getNode(charId);
      if (!node || node.type !== 'characteristic') return;
      const questions = buildQuestions('characteristic', charId, testType);
      if (!questions || !questions.length) {
        alert('Недостаточно данных для теста.');
        return;
      }
      quizState = {
        scope: 'characteristic',
        scopeId: charId,
        testType,
        questions: shuffle(questions),
        currentIndex: 0,
        total: questions.length,
        correctCount: 0
      };
      quizHeaderTitleEl.textContent = 'Тест: ' + (node.name || '');
      showQuiz();
    }

    function showQuiz() {
      renderQuiz();
      document.getElementById('appRoot').style.display = 'none';
      quizScreenEl.style.display = 'flex';
    }

    function exitQuiz() {
      quizState = null;
      quizScreenEl.style.display = 'none';
      document.getElementById('appRoot').style.display = 'grid';
    }

    function restartQuiz() {
      if (!quizState) return;
      quizState.questions = shuffle(quizState.questions);
      quizState.currentIndex = 0;
      quizState.correctCount = 0;
      renderQuiz();
    }

    function renderQuiz() {
      if (!quizState) return;
      const { questions, currentIndex, total } = quizState;
      const q = questions[currentIndex];

      quizProgressEl.textContent = 'Вопрос ' + (currentIndex + 1) + ' из ' + total;
      quizQuestionEl.textContent = q.questionText || '';
      quizOptionsEl.innerHTML = '';
      quizMessageEl.textContent = '';
      btnQuizNext.classList.add('btn-hidden');

      if (q.type === 'single') {
        q._answered = false;
        q.options.forEach(opt => {
          const btn = document.createElement('button');
          btn.className = 'btn btn-option';
          btn.textContent = opt.text || '';
          btn.dataset.id = opt.id;
          btn.onclick = () => {
            if (q._answered) return;
            q._answered = true;
            const isCorrect = q.correctIds.includes(opt.id);
            if (isCorrect) {
              quizState.correctCount++;
            }
            Array.from(quizOptionsEl.children).forEach(b => {
              const id = b.dataset.id;
              if (q.correctIds.includes(id)) {
                b.classList.add('btn-option-correct');
              }
            });
            if (!isCorrect) {
              btn.classList.add('btn-option-wrong');
            }

            if (isCorrect) {
              quizMessageEl.textContent = 'Верно! 👍';
              setTimeout(() => goToNextQuestion(), 450);
            } else {
              quizMessageEl.textContent =
                'Неверно. Правильный ответ: ' + (q.correctAnswerText || '');
              btnQuizNext.classList.remove('btn-hidden');
            }
          };
          quizOptionsEl.appendChild(btn);
        });
      } else if (q.type === 'multi') {
        q._selected = new Set();
        q._answered = false;

        q.options.forEach(opt => {
          const btn = document.createElement('button');
          btn.className = 'btn btn-option';
          btn.textContent = opt.text || '';
          btn.dataset.id = opt.id;
          btn.onclick = () => {
            if (q._answered) return;
            if (q._selected.has(opt.id)) {
              q._selected.delete(opt.id);
              btn.classList.remove('btn-option-selected');
            } else {
              q._selected.add(opt.id);
              btn.classList.add('btn-option-selected');
            }
          };
          quizOptionsEl.appendChild(btn);
        });

        const btnCheck = document.createElement('button');
        btnCheck.className = 'btn btn-sm btn-primary';
        btnCheck.textContent = 'Готово / проверить';
        btnCheck.onclick = () => {
          if (q._answered) return;
          q._answered = true;
          const selected = Array.from(q._selected || []);
          const correctSet = new Set(q.correctIds || []);
          const selectedSet = new Set(selected);
          let allCorrect = true;
          if (correctSet.size !== selectedSet.size) {
            allCorrect = false;
          } else {
            for (const id of correctSet) {
              if (!selectedSet.has(id)) {
                allCorrect = false;
                break;
              }
            }
          }

          Array.from(quizOptionsEl.children).forEach(b => {
            const id = b.dataset.id;
            if (!id) return;
            if (correctSet.has(id)) {
              b.classList.add('btn-option-correct');
            } else if (selectedSet.has(id)) {
              b.classList.add('btn-option-wrong');
            }
          });

          if (allCorrect) {
            quizState.correctCount++;
            quizMessageEl.textContent = 'Все правильные пункты выбраны! 👍';
            setTimeout(() => goToNextQuestion(), 550);
          } else {
            quizMessageEl.textContent =
              'Есть ошибки. Правильные пункты:\n' +
              (q.correctAnswerText || '');
            btnQuizNext.classList.remove('btn-hidden');
          }
        };
        quizOptionsEl.appendChild(btnCheck);
      }
    }

    function goToNextQuestion() {
      if (!quizState) return;
      quizState.currentIndex++;
      if (quizState.currentIndex >= quizState.total) {
        alert(
          'Тест завершён.\n' +
          'Правильных ответов: ' +
          quizState.correctCount +
          ' из ' +
          quizState.total
        );
        exitQuiz();
      } else {
        renderQuiz();
      }
    }

    // ===== CREATE MODAL =====

    let createDialogState = null;
    let createConfigScope = 'subject';
    let createConfigPresetSubject = 'history';
    let createConfigPresetPersonal = 'notes';
    let createPatternType = 'assertion';

    function openCreateDialog(kind, parentId) {
      createDialogState = { kind, parentId };

      if (kind === 'category') {
        createModalTitleEl.textContent = 'Новая категория';
        createModalSubtitleEl.textContent =
          parentId === state.rootId
            ? 'Это корневая категория. Можно выбрать конфигурацию (История, Англ, Личное).'
            : 'Название новой подкатегории.';
        createNameLabelEl.textContent = 'Название категории';
        createConfigBlockEl.style.display =
          parentId === state.rootId ? 'block' : 'none';
        if (createPatternTypeBlockEl) createPatternTypeBlockEl.style.display = 'none';
      } else {
        createModalTitleEl.textContent = 'Новый паттерн';
        createModalSubtitleEl.textContent =
          'Дай имя паттерну и выбери тип фактов внутри него.';
        createNameLabelEl.textContent = 'Название паттерна';
        createConfigBlockEl.style.display = 'none';
        if (createPatternTypeBlockEl) createPatternTypeBlockEl.style.display = 'block';
      }

      createNameInputEl.value = '';
      createConfigScope = 'subject';
      createConfigPresetSubject = 'history';
      createConfigPresetPersonal = 'notes';
      createPatternType = 'assertion';
      updateConfigSegUI();
      updatePatternTypeUI();

      createModalEl.style.display = 'flex';
      setTimeout(() => createNameInputEl.focus(), 0);
    }

    function closeCreateDialog() {
      createModalEl.style.display = 'none';
      createDialogState = null;
    }

    function updateConfigSegUI() {
      Array.from(segConfigScopeEl.querySelectorAll('button')).forEach(b => {
        b.classList.toggle('active', b.dataset.scope === createConfigScope);
      });
      if (createConfigScope === 'subject') {
        configPresetSubjectEl.style.display = 'block';
        configPresetPersonalEl.style.display = 'none';
      } else {
        configPresetSubjectEl.style.display = 'none';
        configPresetPersonalEl.style.display = 'block';
      }
      Array.from(segConfigPresetSubjectEl.querySelectorAll('button')).forEach(b => {
        b.classList.toggle('active', b.dataset.preset === createConfigPresetSubject);
      });
      Array.from(segConfigPresetPersonalEl.querySelectorAll('button')).forEach(b => {
        b.classList.toggle('active', b.dataset.preset === createConfigPresetPersonal);
      });
    }


    function updatePatternTypeUI() {
      if (!segPatternTypeEl) return;
      Array.from(segPatternTypeEl.querySelectorAll('button')).forEach(b => {
        b.classList.toggle('active', b.dataset.ptype === createPatternType);
      });
    }

    // ===== EXPORT / IMPORT =====

    btnExport.onclick = () => {
      const json = JSON.stringify(state, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'exam-db.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    };

    btnImport.onclick = () => {
      fileInput.value = '';
      fileInput.click();
    };

    fileInput.onchange = (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (!data || typeof data !== 'object' || !data.nodes) {
            alert('Файл не похож на базу Помогатора.');
            return;
          }
          state = data;
          currentNodeId = state.rootId || 'root';
          saveState();
          render();
        } catch (err) {
          console.error(err);
          alert('Не удалось прочитать JSON-файл.');
        }
      };
      reader.readAsText(file, 'utf-8');
    };

    // ===== EVENT BINDINGS =====

    if (segPatternTypeEl) {
      segPatternTypeEl.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (!btn || !btn.dataset.ptype) return;
        createPatternType = btn.dataset.ptype;
        updatePatternTypeUI();
      });
    }

    btnCreateRootCategory.onclick = () => {
      const node = getNode(currentNodeId) || getNode(state.rootId);
      const parentId = node && node.type === 'category' ? node.id : state.rootId;
      openCreateDialog('category', parentId);
    };

    if (btnRootsAdd) {
      btnRootsAdd.onclick = () => openCreateDialog('category', state.rootId);
    }

    segConfigScopeEl.addEventListener('click', e => {
      const btn = e.target.closest('button');
      if (!btn) return;
      createConfigScope = btn.dataset.scope;
      updateConfigSegUI();
    });

    segConfigPresetSubjectEl.addEventListener('click', e => {
      const btn = e.target.closest('button');
      if (!btn) return;
      createConfigPresetSubject = btn.dataset.preset;
      updateConfigSegUI();
    });

    segConfigPresetPersonalEl.addEventListener('click', e => {
      const btn = e.target.closest('button');
      if (!btn) return;
      createConfigPresetPersonal = btn.dataset.preset;
      updateConfigSegUI();
    });

    btnCreateClose.onclick = () => closeCreateDialog();
    btnCreateCancel.onclick = () => closeCreateDialog();
    btnCreateConfirm.onclick = () => {
      if (!createDialogState) {
        closeCreateDialog();
        return;
      }
      const { kind, parentId } = createDialogState;
      let name = createNameInputEl.value.trim();
      if (!name) {
        name =
          kind === 'category'
            ? parentId === state.rootId
              ? 'Новая категория'
              : 'Новая подкатегория'
            : 'Новая характеристика';
      }

      if (kind === 'category') {
        let config = null;
        if (parentId === state.rootId) {
          config = {
            scope: createConfigScope,
            preset:
              createConfigScope === 'subject'
                ? createConfigPresetSubject
                : createConfigPresetPersonal
          };
        }
        const id = createCategory(name, parentId, config);
        currentNodeId = id;
      } else {
        const id = createCharacteristic(name, parentId, createPatternType);
        currentNodeId = id;
      }

      closeCreateDialog();
      render();
      renderRootsScreen();
    };

    // quiz buttons
    btnQuizExit.onclick = () => exitQuiz();
    btnQuizRestart.onclick = () => restartQuiz();
    btnQuizNext.onclick = () => goToNextQuestion();

    // facts buttons
    btnFactsClose.onclick = () => exitFacts();
    btnFactPrev.onclick = () => {
      if (!factsState) return;
      if (factsState.currentIndex > 0) {
        factsState.currentIndex--;
        renderFacts();
      }
    };
    btnFactNext.onclick = () => {
      if (!factsState) return;
      if (factsState.currentIndex < factsState.items.length - 1) {
        factsState.currentIndex++;
        renderFacts();
      }
    };

    // ===== Экран выбора корня =====

    function renderRootsScreen() {
      if (!rootsListEl) return;

      rootsListEl.innerHTML = '';

      const root = getNode(state.rootId);
      const hasUserRoot = !!root;

      // --- СЕКЦИЯ: твои корни ---
      if (hasUserRoot) {
        const userSection = document.createElement('div');
        userSection.className = 'roots-section';

        const userTitle = document.createElement('div');
        userTitle.className = 'roots-section-title';
        userTitle.textContent = 'твои корни';
        userSection.appendChild(userTitle);

        const items = (root.children || [])
          .map(id => getNode(id))
          .filter(n => n && n.type === 'category');

        if (!items.length) {
          const empty = document.createElement('div');
          empty.className = 'roots-empty';
          empty.textContent = 'Пока нет корней. Нажми «+», чтобы создать первый.';
          userSection.appendChild(empty);
        } else {
          items.forEach(node => {
            const row = document.createElement('div');
            row.className = 'root-item';
            row.dataset.id = node.id;
            row.dataset.source = 'user';

            const star = document.createElement('div');
            star.className = 'root-item-star';
            star.textContent = '✶';

            const label = document.createElement('div');
            label.className = 'root-item-label';
            label.textContent = 'ПРЕДМЕТ // ' + (node.name || '(без названия)');

            row.appendChild(star);
            row.appendChild(label);

            userSection.appendChild(row);
          });
        }

        rootsListEl.appendChild(userSection);
      }

      // --- СЕКЦИЯ: item:корни (корни разработчика) ---
      if (window.__developerState && window.__developerState.nodes) {
        const devRootId = window.__developerState.rootId;
        const devRoot = window.__developerState.nodes[devRootId];
        if (devRoot) {
          const devItems = (devRoot.children || [])
            .map(id => window.__developerState.nodes[id])
            .filter(n => n && n.type === 'category');

          if (devItems.length) {
            const devSection = document.createElement('div');
            devSection.className = 'roots-section';

            const devTitle = document.createElement('div');
            devTitle.className = 'roots-section-title';
            devTitle.textContent = 'item:корни (корни разработчика)';
            devSection.appendChild(devTitle);

            devItems.forEach(node => {
              const row = document.createElement('div');
              row.className = 'root-item';
              row.dataset.id = node.id;
              row.dataset.source = 'dev';

              const star = document.createElement('div');
              star.className = 'root-item-star';
              star.textContent = '✶';

              const label = document.createElement('div');
              label.className = 'root-item-label';
              label.textContent = 'DEV // ' + (node.name || '(без названия)');

              row.appendChild(star);
              row.appendChild(label);

              devSection.appendChild(row);
            });

            rootsListEl.appendChild(devSection);
          }
        }
      }
    }

    // ===== MAIN RENDER =====

    function render() {
      buildBreadcrumb(currentNodeId);
      renderTree();
      renderDetails();
    }

    render();
  </script>

  <script>
    // Переключение экранов и микро‑логика обёртки
    (function () {
      const screens = {
        splash: document.getElementById('screen-splash'),
        brain: document.getElementById('screen-brain'),
        roots: document.getElementById('screen-roots'),
        app: document.getElementById('screen-app')
      };

      function showScreen(name) {
        Object.values(screens).forEach(function (el) {
          if (!el) return;
          el.classList.remove('screen-visible');
        });
        if (screens[name]) {
          screens[name].classList.add('screen-visible');
        }
        if (name === 'app') {
          render();
        } else if (name === 'roots') {
          renderRootsScreen();
        }
      }

      const splash = screens.splash;
      if (splash) {
        splash.addEventListener('click', function () {
          showScreen('brain');
        });
        // Авто-переход на второй экран
        setTimeout(function () {
          showScreen('brain');
        }, 2200);
      }

      const btnGoToApp = document.getElementById('btnGoToApp');
      if (btnGoToApp) {
        btnGoToApp.addEventListener('click', function () {
          renderRootsScreen();
          showScreen('roots');
        });
      }

      const brainTitle = document.getElementById('brainTitle');
      if (brainTitle) {
        brainTitle.addEventListener('click', function () {
          renderRootsScreen();
          showScreen('roots');
        });
      }

      const rootsList = document.getElementById('rootsList');
      if (rootsList) {
        rootsList.addEventListener('click', function (e) {
          const item = e.target.closest('.root-item');
          if (!item) return;
          const id = item.dataset.id;
          if (!id) return;

          const source = item.dataset.source || 'user';

          // Сначала сброс тестов/фактов
          quizState = null;
          factsState = null;

          if (source === 'dev') {
            if (!window.__developerState || !window.__developerState.nodes) {
              alert('Корни разработчика ещё не загружены.');
              return;
            }
            // Подгружаем базу разработчика как основную
            state = JSON.parse(JSON.stringify(window.__developerState));
            currentNodeId = id;
            saveState();
          } else {
            currentNodeId = id;
          }

          showScreen('app');
        });
      }

      const backToBrain = document.getElementById('backToBrain');
      if (backToBrain) {
        backToBrain.addEventListener('click', function () {
          showScreen('brain');
        });
      }

      const backToBrainRoots = document.getElementById('backToBrainRoots');
      if (backToBrainRoots) {
        backToBrainRoots.addEventListener('click', function () {
          showScreen('brain');
        });
      }

      const sidebarToggleFixed = document.getElementById('sidebarToggleFixed');
      if (sidebarToggleFixed) {
        sidebarToggleFixed.addEventListener('click', function () {
          const appRoot = document.getElementById('appRoot');
          if (!appRoot) return;
          const collapsed = appRoot.classList.toggle('sidebar-collapsed');
          sidebarToggleFixed.textContent = collapsed ? '▶' : '◀';
        });
      }

      // Текст про мозг
      const brainIcon = document.getElementById('brainIcon');
      const brainStory = document.getElementById('brainStory');
      const brainStoryClose = document.getElementById('brainStoryClose');

      if (brainIcon && brainStory && brainStoryClose) {
        brainIcon.addEventListener('click', function () {
          brainStory.classList.add('visible');
        });
        brainStoryClose.addEventListener('click', function () {
          brainStory.classList.remove('visible');
        });
      }
    })();
  </script>
</body>
</html>
